<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/global/head.jpg">
  <link rel="icon" type="image/png" href="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/global/head.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="">
  <meta name="description" content="vinkle&#39;s space">
  <meta name="author" content="Vinkle">
  <meta name="keywords" content="">
  <title>C++ Template-1 函数模板 - vinkle&#39;s space</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Vinkle's space</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/global/post_front.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-09 08:30">
      2020年7月9日 早上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      94
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年10月12日 晚上
                
              </p>
            
            <article class="markdown-body">
              <p>通过大量的例子介绍了C++函数模板。你可以学习到如何使用C++的函数模板以及使用时需要注意的要点。</p>
<a id="more"></a>

<p>这是本系列<strong>第一篇</strong>文章，以下是本系列文章目录。</p>
<p><a href="#1-函数模板">1. 函数模板（本文）</a></p>
<p><a href="https://vinkle.top/2020/07/17/cpp-template-2/#2-%E7%B1%BB%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">2. 类模板 </a></p>
<p><a href="https://vinkle.top/2020/07/22/cpp-template-3/#3-1-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">3. 非类型模板参数</a></p>
<p><a href="https://vinkle.top/2020/09/06/cpp-template-4/#4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">4. 可变参数模板</a></p>
<p><a href="https://vinkle.top/2020/10/12/cpp-template-5/#5-%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener">5. 基础技术</a></p>
<h1 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a>1. 函数模板</h1><p>本章介绍了函数模板。函数模板是被参数化的函数，因此他们代表了一组行为相似的函数(a family of functions)。</p>
<h2 id="1-1-初识函数模板"><a href="#1-1-初识函数模板" class="headerlink" title="1.1. 初识函数模板"></a>1.1. 初识函数模板</h2><p>函数模板提供了适用于不同类型的函数行为。也就是说，函数模板代表了一组行为相似的函数。函数模板看起来几乎就跟普通函数一样，除了某些信息没有被确定以外。我们通过下面一个简单的例子来说明这一问题。</p>
<h3 id="1-1-1-定义模板"><a href="#1-1-1-定义模板" class="headerlink" title="1.1.1 定义模板"></a>1.1.1 定义模板</h3><p>一下是一个函数模板，它返回两数中的最大值</p>
<pre><code class="hljs c++"><span class="hljs-comment">//max1.hpp</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>这个模板第一了一系列函数，他们都返回了两个参数中值较大的拿一个。这两个参数的类型并没有确定，而是被表示为<strong>模板参数(template parameter)</strong> <code>T</code>。</p>
<p>模板参数应该按照如下的语法来声明：</p>
<p><em>template &lt;由逗号分隔的模板参数&gt;</em></p>
<p>在本例中，模板参数是 <code>typename T</code> 。关键字 <code>typename</code> 标识了一个<em>类型参数</em>，即 <code>T</code> 是<strong>类型参数(type parameter)</strong>，你可以用任意的标识作为类型参数的参数名，但是习惯上我们使用 <code>T</code> 作为参数名。本例中，类型 <code>T</code> 必须支持小于运算符，因为 <code>a</code> 和 <code>b</code> 比较时运用到了它。另外比较隐秘的一点，为了支持返回值，<code>T</code> 还应该是可拷贝的。</p>
<h3 id="1-1-2-使用模板"><a href="#1-1-2-使用模板" class="headerlink" title="1.1.2 使用模板"></a>1.1.2 使用模板</h3><p>下面的程序展现了如何使用 <code>max()</code>模板：</p>
<pre><code class="hljs c++"><span class="hljs-comment">//max1.cpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"max1.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(7,i): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>,i) &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-keyword">double</span> f1 = <span class="hljs-number">3.4</span>;
    <span class="hljs-keyword">double</span> f2 = <span class="hljs-number">-6.7</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(f1,f2): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(f1,f2) &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"mathematics"</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"math"</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(s1,s2): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(s1,s2) &lt;&lt; <span class="hljs-string">'\n'</span>;
&#125;</code></pre>

<p>注意在调用的 <code>max()</code> 模板的时候使用了作用域限制符 <code>::</code>。这样保证了程序将会在全局<strong>命名空间(namespace)</strong>中查找 <code>max()</code> 模板。</p>
<p>在此程序中，<code>max()</code>被调用了三次：一次是比较两个<code>int</code>，一次是比较两个<code>double</code>，还有一次是比较两个 <code>std::string</code>。每一次都会算出最大值。下面是输出结果：</p>
<pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-number">7</span>,i)</span></span>: <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(f1,f2)</span></span>: <span class="hljs-number">3.4</span>
<span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(s1,s2)</span></span>: mathematics</code></pre>

<p>在编译阶段，模板并不是被编译成一个可以支持多种类型的实体。而是对每一个用于该模板的类型都会产生一个独立的实体。因此在本例中，<code>max()</code> 会被编译出三个实体，因为它被用于三种类型。比如第一次调用时：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;
... <span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, i) ...</code></pre>

<p>函数模板的类型参数 T 是<code>int</code>。因此在语义上等价于调用如下函数：</p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>以上用具体类型取代模板类型参数的过程叫做<strong>实例化(instantiation)</strong>。它会产生模板的一个实例。</p>
<p>值得注意的是，模板的实例化不需要程序员做额外的请求，只是简单的使用函数模板就会触发这一实例化过程。</p>
<p>同样的，另外两次调用也会分别为 <code>double</code> 和 <code>std::string</code> 各实例化出一个实例，就像是分别定义了下面两个函数一样：</p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>)</span></span>;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>)</span></span>;</code></pre>

<p>另外，只要结果是有意义的，void 作为模板参数也是有效的。比如:</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">foo</span><span class="hljs-params">(T*)</span></span>
<span class="hljs-function"></span>&#123; &#125;
<span class="hljs-keyword">void</span>* vp = <span class="hljs-literal">nullptr</span>;
foo(vp); <span class="hljs-comment">// OK: 模板参数被推导为 void</span>
foo(<span class="hljs-keyword">void</span>*)</code></pre>

<h3 id="1-1-3-二阶段翻译-Two-Phase-Translation"><a href="#1-1-3-二阶段翻译-Two-Phase-Translation" class="headerlink" title="1.1.3 二阶段翻译(Two-Phase Translation)"></a>1.1.3 二阶段翻译(Two-Phase Translation)</h3><p>在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误(compile-time error)。比如：</p>
<pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">complex</span>&lt;<span class="hljs-keyword">float</span>&gt; c1, c2; <span class="hljs-comment">// std::complex&lt;&gt; 没有提供小于运算符</span>
...
::<span class="hljs-built_in">max</span>(c1,c2); <span class="hljs-comment">// 编译期 ERROR</span></code></pre>

<p>在编写是不会立刻提醒错误，因为模板是分两步编译的：</p>
<ol>
<li><p>在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面：</p>
<ul>
<li>语法检查。比如少了分号。</li>
<li>检查使用未定义的不依赖于模板参数的未知名称（类型名，函数名，…）。</li>
<li>检查不依赖于模板参数的<strong>静态断言(static assertion)</strong>；</li>
</ul>
</li>
<li><p>在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。</p>
<p>例如：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span>
<span class="hljs-function"></span>&#123;
    undeclared(); <span class="hljs-comment">// 如果 undeclared() 未定义，第一阶段就会报错</span>
    undeclared(t); <span class="hljs-comment">//如果 undeclared(t) 未定义，第二阶段会报错</span>
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &gt; <span class="hljs-number">10</span>,<span class="hljs-string">"int too small"</span>); <span class="hljs-comment">// 总是报错</span>
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-keyword">sizeof</span>(T) &gt; <span class="hljs-number">10</span>, <span class="hljs-string">"T too small"</span>); <span class="hljs-comment">//只会在第二阶段报错</span>
&#125;</code></pre>

</li>
</ol>
<p>需要注意的是，有些编译器并不会执行第一阶段中的所有检查。因此如果模板没有被至少实例化一次的话，你可能一直都不会发现代码中的常规错误。</p>
<h4 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h4><p>两阶段的编译检查给模板的处理带来了一个问题：当实例化一个模板的时候，编译器需要（一定程度上）看到模板的完整定义。这不同于函数编译和链接分离的思想，函数在编译阶段只需要声明就够了。后面将讨论如何应对这一问题。现在暂时采取最简单的方法：将模板的实现写在头文件里。</p>
<h2 id="1-2-模板参数推导"><a href="#1-2-模板参数推导" class="headerlink" title="1.2. 模板参数推导"></a>1.2. 模板参数推导</h2><p>当我们调用形如 <code>max()</code> 的函数模板来处理某些变量时，模板参数将由被传递的调用参数决定。如果我们传递两个 <code>int</code> 类型的参数给模板函数，C++编译器会将模板参数 T 推导为 <code>int</code>。</p>
<p>不过 T 可能只是实际传递的函数参数类型的一部分。比如我们定义了如下接受常量引用作为函数参数的模板：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; a, T <span class="hljs-keyword">const</span>&amp; b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>此时如果我们传递 <code>int</code> 类型的调用参数，由于调用参数和 <code>int const &amp;</code> 匹配，类型参数 T 将被推导为<code>int</code>。</p>
<h3 id="1-2-1-类型推导中的类型转换"><a href="#1-2-1-类型推导中的类型转换" class="headerlink" title="1.2.1 类型推导中的类型转换"></a>1.2.1 类型推导中的类型转换</h3><p>在类型推导的时候自动的类型转换是受限制的：</p>
<ul>
<li>如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的两个参数，它们实参的类型必须完全一样。</li>
<li>如果调用参数是按值传递的，那么只有<strong>退化(decay)</strong>这一类简单转换是被允许的：<code>const</code> 和 <code>volatile</code> 限制符会被忽略，引用被转换成被引用的类型，<strong>数组(raw array)</strong>和函数被转换为相应的指针类型。通过模板类型参数 T 定义的两个参数，它们实参的类型在退化后必须一样。</li>
</ul>
<p>例如：</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>;
...
<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> c = <span class="hljs-number">42</span>;
max(i, c); <span class="hljs-comment">// OK: T 被推导为 int</span>
max(c, c); <span class="hljs-comment">// OK: T 被推导为 int</span>
<span class="hljs-keyword">int</span>&amp; ir = i;
max(i, ir); <span class="hljs-comment">// OK: T 被推导为 int</span>
<span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>];
max(&amp;i, arr); <span class="hljs-comment">// OK: T 被推导为 int*</span></code></pre>

<p>但是像下面这样是错误的：</p>
<pre><code class="hljs c++"><span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// ERROR: 不确定 T 该被推导为 int 还是 double</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;
<span class="hljs-built_in">max</span>(<span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">//ERROR: 不确定 T 该被推导为 const[6] 还是 std::string</span></code></pre>

<p>有三种办法解决以上错误：</p>
<ol>
<li><p>对参数进行类型转换，使参数同时匹配。</p>
<pre><code class="hljs c++"><span class="hljs-built_in">max</span>(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>), <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK</span></code></pre>
</li>
<li><p>显示地指出T的类型取阻止编译器进行类型推导。</p>
<pre><code class="hljs c++"><span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK</span></code></pre>
</li>
<li><p>指明参数可能有多个不同的类型（使用多个模板参数）。</p>
</li>
</ol>
<h3 id="1-2-2-对默认参数的类型推导"><a href="#1-2-2-对默认参数的类型推导" class="headerlink" title="1.2.2 对默认参数的类型推导"></a>1.2.2 对默认参数的类型推导</h3><p>需要注意的是，类型推导并不适用于默认参数。例如：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T = <span class="hljs-string">""</span>)</span></span>;
...
f(<span class="hljs-number">1</span>); <span class="hljs-comment">// OK: T 被推导为 int，调用 f&lt;int&gt; (1)</span>
f(); <span class="hljs-comment">// ERROR: 无法推导 T 的类型</span></code></pre>

<p>为应对这一情况，你需要给模板类型参数也声明一个默认参数</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;
<span class="hljs-keyword">void</span> f(T = <span class="hljs-string">""</span>);
...
f(); <span class="hljs-comment">// OK</span></code></pre>

<h2 id="1-3-多模板参数"><a href="#1-3-多模板参数" class="headerlink" title="1.3. 多模板参数"></a>1.3. 多模板参数</h2><p>目前我们看到与函数模板有关的两组参数：</p>
<ol>
<li><p><strong>模板参数(template parameters)</strong>，定义在函数模板前的尖括号中：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// T 是模板参数</span></code></pre>
</li>
<li><p><strong>调用参数(call parameters)</strong>，定义在函数模板名称后的圆括号中：</p>
<pre><code class="hljs c++"><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> <span class="hljs-comment">// a 和 b 是调用参数</span></span></code></pre>


</li>
</ol>
<p>模板参数可以是一个或者多个。比如，你可以定义这样一个 <code>max()</code> 模板，它可能接受两个不同类型的调用参数：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function">T1 <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;
...
<span class="hljs-keyword">auto</span> m = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK, 但是返回类型是第一个模板参数 T1 的类型</span></code></pre>

<p>看上去如你所愿，它是可以接受两个不同类型的调用参数。但是，这也导致了一个问题。如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地一样，当应该返回另一个类型的值的时候，返回值会被做类型转换。这将导致返回值的具体类型和参数的传递顺序有关。如果传递 <code>66.66</code> 和 <code>42</code> 给这个函数模板，返回值是 <code>double</code> 类型的 <code>66.66</code>，但是如果传递 <code>42</code> 和 <code>66.66</code>，返回值却是 <code>int</code> 类型的 <code>66</code>。</p>
<p>C++提供了多种方法来解决这一问题：</p>
<ol>
<li>引入第三个模板参数作为返回类型。</li>
<li>让编译器找出返回类型</li>
<li>将返回类型定义为两个参数类型的<strong>公共类型(common type)</strong>。</li>
</ol>
<h3 id="1-3-1-返回类型的模板参数"><a href="#1-3-1-返回类型的模板参数" class="headerlink" title="1.3.1 返回类型的模板参数"></a>1.3.1 返回类型的模板参数</h3><p>我们可以像调用普通函数一样条用函数模板，也可以显式地指出模板参数的参数类型。</p>
<p>当模板参数和调用参数直接没有必然联系，且模板参数不能确定是，就要显式地指明模板参数。例如，你可以引入第三个模板参数来指定函数模板的返回类型：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> RT&gt;
<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;</code></pre>

<p>但是模板类型推导不会考虑返回类型，而 <code>RT</code> 不是函数的调用参数的类型。因此 <code>RT</code> 不会被推导。这样就必须显式的指明模板参数的类型。比如：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> RT&gt;
<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;
...
::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">double</span>,<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK, 但是太繁琐</span></code></pre>

<p>到目前为止，我们看到的情况是，要么所有模板参数都被显式指定，要么一个都不指定。另一种办法是只指定第一个模板参数的类型，其余参数的类型通过推导获得。通常而言，我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推导出来为止。因此，如果你改变了上面例子中的模板参数顺序，调用时只需要指定返回值的类型就可以了：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;
...
::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>) <span class="hljs-comment">//OK: 返回类型是 double，T1 和 T2 根据调用参数推导</span></code></pre>

<p>在本例中，调用 <code>max&lt;double&gt;</code> 时，显式的指明了 <code>RT</code> 的类型是 <code>double</code>，<code>T1</code> 和 <code>T2</code> 则基于传入调用参数的类型被推导为 <code>int</code> 和 <code>double</code>。<br>然而改进版的 <code>max()</code> 并没有带来显著的变化。使用单模板参数的版本，即使传入的两个调用参数的类型不同，你依然可以显式的指定模板参数类型（也作为返回类型）。因此为了简洁，我们最好还是使用单模板参数的版本。</p>
<h3 id="1-3-2-推导返回类型"><a href="#1-3-2-推导返回类型" class="headerlink" title="1.3.2 推导返回类型"></a>1.3.2 推导返回类型</h3><p>如果返回类型是由模板参数决定的，那么推导返回类型最简单也是<strong>最好的</strong>办法就是让编译器来做这件事。C++14 开始，这成为可能，而且不需要把返回类型声明为任何模板参数类型（不过你需要声明返回类型为 <code>auto</code>）：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>在 C++14 之前，要想让编译器推导出返回类型，就必须让或多或少的函数实现成为函数声明的一部分。在 C++11 中，<strong>尾置返回类型(trailing return type)</strong>允许我们使用函数的调用参数。也就是说，我们可以基于运算符 <code>?:</code> 的结果声明返回类型：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b)
&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>在这里，返回类型是由运算符<code>?:</code>的结果决定的，这虽然复杂但是可以得到想要的结果。</p>
<p>需要注意的是</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b);</code></pre>

<p>是一个声明，编译器在编译阶段会根据  <code>?:</code>  调用参数 <code>a</code> 和 <code>b</code> 的返回结果来决定实际的返回类型。不过具体实现时不一定需要匹配。所以事实上只要使用 <code>true</code> 作为运算符 <code>?:</code> 的条件就行了：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
auto max(T1 a, T2 b) -&gt; decltype(true ? a : b);</code></pre>

<p>但是在某些情况下会有一个严重的问题：由于 <code>T</code> 可能是引用类型，返回类型就也可能被推导为引用类型。因此你应该返回的是<strong>退化(decay)</strong>后的 <code>T</code>，像下面这样：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type
&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>这里用到了 <em>type trait</em> <code>std::decay&lt;&gt;</code>，它的 <code>type</code> 成员返回目标类型，它定义在标准库 <code>&lt;type_traits&gt;</code> 中。因为其 <code>type</code> 成员是结果类型，为了获取其结果，应该用关键字 <code>typename</code> 来修饰这个表达式。</p>
<p>注意，在初始化 <code>auto</code> 类型是总是<strong>退化(decay)</strong>后的类型。它同样支持返回类型是 <code>auto</code>。 用 <code>auto</code> 作为返回结果的效果就像下面那样，<code>a</code> 的类型被推导为 <code>i</code> 退化后的类型，即为 <code>int</code>：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;
<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span>&amp; ir = i; <span class="hljs-comment">// ir 是 i 的引用</span>
<span class="hljs-keyword">auto</span> a = ir; <span class="hljs-comment">// a 的类型是 ir decay 之后的类型，也就是int</span></code></pre>

<h3 id="1-3-3-作为通用类型返回"><a href="#1-3-3-作为通用类型返回" class="headerlink" title="1.3.3 作为通用类型返回"></a>1.3.3 作为通用类型返回</h3><p>从C++11 开始，标准库提供了一种指定“更一般类型”的方式。<code>std::common_type&lt;&gt;::type</code> 产生的类型是他的两个（或更多）模板参数的公共类型。比如：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
std::common_type_t&lt;T1, T2&gt; max(T1 a, T2 b)
&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>同样的，<code>std::common_type&lt;&gt;</code> 也是一个 <em>type trait</em>，定义在标准库 <code>type_traits</code> 中，它返回一个结构体，其 <code>type</code> 成员是结果类型。其主要的应用如下：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::common_type&lt;T1, T2&gt;::type <span class="hljs-comment">//since C++11</span></code></pre>

<p>在C++14后，你可以简化其用法，仅需在后面加一个 <code>_t</code>，就可以省掉 <code>typename</code> 和 <code>::type</code>，简化后的版本变为：</p>
<pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">common_type_t</span>&lt;T1, T2&gt; <span class="hljs-comment">// equivalent since C++14</span></code></pre>

<p><code>std::common_type&lt;&gt;</code> 的实现用到了一些比较取巧的模板编程手法（后续会介绍）。它根据运算符 <code>?:</code> 的语法规则或者对某些类型的特化来决定目标类型。因此 <code>::max(4, 7.2)</code> 和 <code>::max(7.2, 4)</code> 都返回 <code>double</code> 类型的 <code>7.2</code>。需要注意的是，<code>std::common_type&lt;&gt;</code>的结果也是<strong>退化(decay)</strong>的。</p>
<h2 id="1-4-缺省模板参数-Default-Template-Arguments"><a href="#1-4-缺省模板参数-Default-Template-Arguments" class="headerlink" title="1.4. 缺省模板参数(Default Template Arguments)"></a>1.4. 缺省模板参数(Default Template Arguments)</h2><p>你也可以给函数模板参数指定一个默认值。这些默认值被称为<strong>缺省模板参数(default template arguments)</strong>【也称为默认模板参数】并且可以用在任何类型的模板中。它们甚至可以通过前面的模板参数来决定自己的类型。</p>
<p>例如，如果你想像前面叙述的那样是返回类型有多个模板参数，你可以定义一个模板参数 <code>RT</code>，并将其默认类型声明为其他两个模板的公共类型。同样的我们也有多种实现方法：</p>
<ol>
<li><p>可以直接使用 <code>?:</code> 运算符。不过由于我们必须在<strong>调用参数(call parameters)</strong> <code>a</code> 和 <code>b</code> 被声明之前使用运算符 <code>?:</code>，我们只能用它们的类型：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2,<span class="hljs-keyword">typename</span> RT = 
          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-literal">true</span> ? T1() : T2())&gt;&gt;
RT <span class="hljs-built_in">max</span>(T1 a, T2 b)
&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>请注意我们使用了 <code>std::decay_t&lt;&gt;</code> 来确保返回的类型不是引用类型。</p>
<p>同样值得注意的是，这一实现方法要求我们能够调用两个模板参数的<strong>默认构造(default constructor)</strong>。还有另一种方法，使用 <code>std::declval</code>，不过这将使得声明部分更加复杂，以后我们会讲到。</p>
</li>
<li><p>我们同样可以使用 <em>type trait</em> <code>std::decay_t&lt;&gt;</code> 作为返回类型的默认值：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2,
          <span class="hljs-keyword">typename</span> RT = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">common_type_t</span>&lt;T1, T2&gt;&gt;
RT <span class="hljs-built_in">max</span>(T1 a, T2 b)
&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>在这里<code>std::common_type_t&lt;&gt;</code> 也是会做退化的，因此返回类型不会是引用。</p>
</li>
</ol>
<p>在以上两种情况下，你可以使用 <code>RT</code> 的默认值作为返回类型：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>);</code></pre>

<p>也可以显式地指出所有的函数模板参数的类型：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">auto</span> b = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7.2</span>, <span class="hljs-number">4</span>);</code></pre>

<p>但是，我们再次遇到这样一个问题：为了显式指出返回类型，我们必须显式的指出全部三个模板参数的类型。因此我们希望能够将返回类型作为第一个模板参数，并且依然能够从其它两个模板参数推断出它的类型。</p>
<p>原则上这是可行的，即使后面的模板参数没有默认值，我们依然可以让第一个模板参数有默认值：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT = <span class="hljs-keyword">long</span>, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
RT <span class="hljs-built_in">max</span>(T1 a, T2 b)
&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>基于这个定义，你可以这样调用：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">long</span> l;
...
<span class="hljs-built_in">max</span>(i, l);     <span class="hljs-comment">// 返回值类型是long (RT 的默认值)</span>
<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">//返回int，因为其被显式指定</span></code></pre>

<p>但是只有当模板参数具有一个“天生的”默认值时，这才有意义。我们真正想要的是从前面的模板参数推导出想要的默认值。原则是这也是可行的（后续会讨论到），但是他是基于类型萃取的，并且会使定义变得更加复杂。</p>
<p>基于以上原因，最好也是最简单的办法就是像<a href="#推导返回类型">前面讨论的那样</a>让编译器来推断出返回类型。</p>
<h2 id="1-5-重载函数模板"><a href="#1-5-重载函数模板" class="headerlink" title="1.5. 重载函数模板"></a>1.5. 重载函数模板</h2><p>像普通函数一样，模板也是可以重载的。也就是说，你可以定义多个有相同函数名的函数，当实际调用的时候，由C++编译器负责决定具体该调用哪一个函数。</p>
<p>下列程序展示了函数模板的重载：</p>
<pre><code class="hljs c++"><span class="hljs-comment">// maximum of two int values:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125; <span class="hljs-comment">// maximum of two values of any type:</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);         <span class="hljs-comment">// 调用非模板函数</span>
    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7.0</span>, <span class="hljs-number">42.0</span>);     <span class="hljs-comment">// 调用 max&lt;double&gt; (通过类型推导)</span>
    ::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);      <span class="hljs-comment">//调用 max&lt;char&gt; (通过类型推导)</span>
    ::<span class="hljs-built_in">max</span>&lt;&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);       <span class="hljs-comment">// 调用 max&lt;int&gt; (通过类型推导)</span>
    ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// 调用 max&lt;double&gt; (无类型推导)</span>
    ::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">42.7</span>);     <span class="hljs-comment">//调用非模板函数</span>
&#125;</code></pre>

<p>这个例子展示了一个非模板函数可以与其同名的函数模板共存，并且这个函数模板可以被实例化与非模板函数具有相同类型的调用函数。在其他因素相同时，模板解析过程<strong>优先选择</strong>非模板函数，而不是模板实例化出来的函数。第一个调用就属于这种情况：</p>
<pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">//两个 int 变量都完美匹配了非模板函数</span></code></pre>

<p>如果模板可以实例化出一个更匹配的函数，那么就会选择这个模板。如第二和第三次调用 <code>max()</code> 时：</p>
<pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-number">7.0</span>, <span class="hljs-number">42.0</span>);     <span class="hljs-comment">// 调用 max&lt;double&gt; (通过类型推导)</span>
::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);      <span class="hljs-comment">//调用 max&lt;char&gt; (通过类型推导)</span></code></pre>

<p>在此模板更加匹配，因为它不需要把 <code>double</code> 和 <code>char</code> 转换为 <code>int</code>。</p>
<p>也可以显式指定一个空的模板列表。这表明它会被解析成一个模板调用，其所有的模板参数会被通过调用参数推断出来：</p>
<pre><code class="hljs c++">::<span class="hljs-built_in">max</span>&lt;&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);       <span class="hljs-comment">// 调用 max&lt;int&gt; (通过类型推导)</span></code></pre>

<p>由于在模板参数推断时<strong>不允许</strong>自动类型转换，而常规函数是允许的，因此最后一个调用会选择非模板参函数（ <code>a</code> 和 <code>42.7</code> 都被转换成 <code>int</code>）：</p>
<pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">42.7</span>);     <span class="hljs-comment">//只有非模板函数允许 nontrivial conversion</span></code></pre>

<p>一个有趣的例子是我们可以专门为 <code>max()</code> 显示指定其返回值类型的模板来进行重载：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>现在我们可以向这样调用 <code>max()</code>:</p>
<pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// 调用第一个函数模板</span>
<span class="hljs-keyword">auto</span> b = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7.2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 调用用第二个函数模板</span></code></pre>

<p>但是想下面这样调用的话：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">auto</span> c = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">//ERROR: 两个函数模板同时匹配</span></code></pre>

<p>两个模板都是匹配的，这会导致模板解析过程不知道该调用哪一个模板，从而导致未知错误。因此当重载函数模板的时候，要保证对任意一个调用，都只会有一个模板匹配。</p>
<p>一个比较有用的例子是为指针和 <code>C-strings</code> 重载 <code>max()</code> 模板：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-comment">// maximum of two values of any type:</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;
<span class="hljs-comment">// maximum of two pointers:</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T *<span class="hljs-title">max</span><span class="hljs-params">(T *a, T *b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> *b &lt; *a ? a : b;
&#125;
<span class="hljs-comment">// maximum of two C -strings :</span>
<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *a, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strcmp</span>(b, a) &lt; <span class="hljs-number">0</span> ? a : b;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">42</span>;
    <span class="hljs-keyword">auto</span> m1 = ::<span class="hljs-built_in">max</span>(a, b); <span class="hljs-comment">// max() for two values of type int</span>

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"hey"</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"you"</span>;
    <span class="hljs-keyword">auto</span> m2 = ::<span class="hljs-built_in">max</span>(s1, s2); <span class="hljs-comment">// max() for two values of type std::string</span>
    
    <span class="hljs-keyword">int</span> *p1 = &amp;b;
    <span class="hljs-keyword">int</span> *p2 = &amp;a;
    <span class="hljs-keyword">auto</span> m3 = ::<span class="hljs-built_in">max</span>(p1, p2); <span class="hljs-comment">// max() for two pointers</span>

    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *x = <span class="hljs-string">"hello"</span>;
    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *y = <span class="hljs-string">"world"</span>;
    <span class="hljs-keyword">auto</span> m4 = ::<span class="hljs-built_in">max</span>(x, y); <span class="hljs-comment">// max() for two C-strings</span>
&#125;</code></pre>

<p>注意上面所有 <code>max()</code> 的重载模板中，调用参数都是按<strong>值</strong>传递的。通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。否则，可能会遇到意想不到的问题。比如，如果你实现了一个按引用传递的 <code>max()</code> 模板，然后又重载了一个按值传递两个 C 字符串作为参数的模板，你不能用接受三个参数的模板来计算三个 C 字符串的最大值：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-comment">// maximum of two values of any type (call-by-reference)</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;a, T <span class="hljs-keyword">const</span> &amp;b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;

<span class="hljs-comment">// maximum of two C-strings (call-by-value)</span>
<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *a, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strcmp</span>(b, a) &lt; <span class="hljs-number">0</span> ? a : b;
&#125;

<span class="hljs-comment">// maximum of three values of any type (call-by-reference)</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;a, T <span class="hljs-keyword">const</span> &amp;b, T <span class="hljs-keyword">const</span> &amp;c)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c); <span class="hljs-comment">// error if max(a,b) uses call-by-value</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">auto</span> m1 = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>, <span class="hljs-number">68</span>); <span class="hljs-comment">// OK</span>
    
    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s1 = <span class="hljs-string">"frederic"</span>;
    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s2 = <span class="hljs-string">"anica"</span>;
    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s3 = <span class="hljs-string">"lucas"</span>;
    <span class="hljs-keyword">auto</span> m2 = ::<span class="hljs-built_in">max</span>(s1, s2, s3); <span class="hljs-comment">//run-time ERROR</span>
&#125;</code></pre>

<p>问题在于当用三个 C 字符串作为参数调用 <code>max()</code> 的时候，</p>
<pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c);</code></pre>

<p>会遇到run-time error，这是因为对C 字符串，<code>max(max(a, b), c)</code> 会创建一个用于返回的临时局部变量，而在返回语句接受后，这个临时变量会被销毁，导致 <code>max()</code> 使用了一个悬空的引用。不幸的是，这个错误几乎在所有情况下都不太容易被发现。</p>
<p>作为对比，在求三个 <code>int</code> 最大值的 <code>max()</code> 调用中，则不会遇到这个问题。这里虽然也会创建三个临时变量，但是这三个临时变量创建在 <code>main()</code> 中，它们的存在时间会持续到语句结束。</p>
<p>这只是模板解析与期望结果不一致的一个例子。另外，要确保函数模板在调用前已经被定义。这是由于我们调用某个函数模板时，不是所有的重载函数都是可见的。比如我们定义了三个参数的 <code>max()</code> 函数，由于它调用适用于两个 <code>int</code> 类型的 <code>max()</code> 时，重载的两个 <code>int</code> 类型的 <code>max()</code> 是不可见的，因此它最终会调用两个参数的模板函数：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-comment">// maximum of two values of any type:</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max&lt;T&gt;() \n"</span>;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125; 

<span class="hljs-comment">// maximum of three values of any type:</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b, T c)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c); <span class="hljs-comment">//仍然使用函数模板</span>
 							  <span class="hljs-comment">//因为重载的声明在后面</span>
&#125;

<span class="hljs-comment">// maximum of two int values:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(int,int) \n"</span>;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">47</span>, <span class="hljs-number">11</span>, <span class="hljs-number">33</span>); 
    <span class="hljs-comment">// OOPS: uses max&lt;T&gt;() instead of max(int,int)</span>
&#125;</code></pre>

<h2 id="1-6-但是，难道我们不应该？"><a href="#1-6-但是，难道我们不应该？" class="headerlink" title="1.6. 但是，难道我们不应该？"></a>1.6. 但是，难道我们不应该？</h2><h3 id="1-6-1-按值传递还是按应用传递？"><a href="#1-6-1-按值传递还是按应用传递？" class="headerlink" title="1.6.1 按值传递还是按应用传递？"></a>1.6.1 按值传递还是按应用传递？</h3><p>我们声明的函数通常都是按值传递，而不是按引用传递。通常而言，建议将按引用传递除简单类型（比如<strong>基础类型(fundamental type)</strong>和 <code>std::string_view</code>）以外的类型，这样可以免除不必要的拷贝成本。</p>
<p>但是出于以下原因，<strong>按值传递</strong>通常更好一些：</p>
<ul>
<li>语法简单。</li>
<li>编译器优化更好。</li>
<li>移动语意是的拷贝成本较低。</li>
<li>某些情况下没有拷贝或者移动。</li>
</ul>
<p>再有，对于模板，还有一些特殊情况：</p>
<ul>
<li>模板可能用于简单类型也可能由于复杂类型，因此如果选择利于复杂类型的方式，可能会对简单类型产生不利的影响。</li>
<li>作为调用者，你可以通过使用 <code>std::ref()</code> 和 <code>std::cref()</code> 决定是否按照引用传递参数。</li>
<li>尽管传递 <em>string literal</em> 和 <em>raw array</em> 会产生一些问题，按时如果按照引用传递它们会产生更大的问题。</li>
</ul>
<p>后续会对此进行进一步讨论，<strong>除了某些不得不用按引用传递的情况，尽量使用按值传递。</strong></p>
<h3 id="1-6-2-为什么不用-inline-呢？"><a href="#1-6-2-为什么不用-inline-呢？" class="headerlink" title="1.6.2 为什么不用 inline 呢？"></a>1.6.2 为什么不用 inline 呢？</h3><p>通常，函数模板不需要声明为 <code>inline</code>。不像普通的 <code>noninline</code> 函数，我们可以把 <code>noninline</code> 函数模板定义在同文件中，然后再多个编译单元里 <code>include</code> 这个头文件。</p>
<p>唯一一个例外是模板对某些类型进行了<strong>全特化(full spcializations)</strong>，这时的结果代码不再是<strong>泛型(generic)</strong>的(所有的模板参数都已经被指定了)。后续会详细讨论。</p>
<p>严格地从语言角度来看，<code>inline</code> 只意味着在程序中函数的定义可以出现很多次。不过它也给了编译器一个暗示，在调用该函数的地方函数应该被展开成 <code>inline</code> 的：这样做在某些情况下可以提高效率，但是在另一些情况下也可能降低效率。现代编译器在没有关键字 <code>inline</code> 暗示的情况下，通常也可以很好的决定是否将函数展开成 <code>inline</code> 的。当然，编译器在做决定的时候依然会将关键字 <code>inline</code> 纳入考虑因素。</p>
<h3 id="1-6-3-为什么不用-constexpr-呢？"><a href="#1-6-3-为什么不用-constexpr-呢？" class="headerlink" title="1.6.3 为什么不用 constexpr 呢？"></a>1.6.3 为什么不用 constexpr 呢？</h3><p>从 C++11 开始，你可以通过关键字 <code>constexpr</code> 来在编译期进行某些运算。对于很多模板来说，这是有意义的。</p>
<p>比如为了可以在编译期使用求最大值的函数，你需要将函数模板定义如下：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b &lt; a ? a : b;
&#125;</code></pre>

<p>通过此，你可以使用此函数在编译期就求出最大值，例如当定义数列的大小时：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">1000u</span>)];</code></pre>

<p>或者指定 <code>std::array&lt;&gt;</code> 的大小：</p>
<pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, ::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), 1000u)&gt; arr;</code></pre>

<p>在这里我们传递的 1000 是 <code>unsigned int</code> 类型，这样可以避免直接比较一个有符号数值和一个无符号数值时产生的警报。</p>
<p>后续也会继续讨论 <code>constexpr</code>。</p>
<h2 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7. 小结"></a>1.7. 小结</h2><ul>
<li>函数模板定义了一组适用于不同类型的函数</li>
<li>当向模板函数传递变量时，函数模板会自行推导模板参数的类型，来决定去实例化出那种类型的函数。</li>
<li>你也可以显式的指出模板参数的类型。</li>
<li>你可以定义模板参数的默认值。这个默认值可以使用该模板参数前面的模板参数的类型，而且其后面的模板参数可以没有默认值。</li>
<li>函数模板可以被重载。</li>
<li>当定义新的函数模板来重载已有的函数模板时，必须要确保在任何调用情况下都只有一个模板是最匹配的。</li>
<li>当你重载函数模板的时候，最好只是显式地指出了模板参数的类型。</li>
<li>确保在调用某个函数模板之前，编译器已经看到了相对应的模板定义。</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C/">C++</a>
                    
                      <a class="hover-with-bg" href="/categories/C/Template/">Template</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">泛型编程</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/13/Dijkstra/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Dijkstra 算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/07/CSAPP_2_1/">
                        <span class="hidden-mobile">CSAPP-2.1 信息表示和处理-信息储存</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "C++ Template-1 函数模板&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  













  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?e29593c0eaefc83ba96301b9153d7d11";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
