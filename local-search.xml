<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2020/07/15/union-find/"/>
    <url>/2020/07/15/union-find/</url>
    
    <content type="html"><![CDATA[<p>并查集是一种树型的数据结构，主要用于处理一些不交集的合并及查询问题。本文通过样例介绍了并查集，并给出了 C++ 算法的实现和两种优化方案。</p><a id="more"></a><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>在计算机科学中，并查集是一种树型的数据结构，主要用于处理一些<strong>不交集（Disjoint Sets）</strong>的合并及查询问题。有一个<strong>联合-查找算法（Union-find Algorithm）</strong>定义了两个用于此数据结构的操作：</p><ul><li><code>Find</code>：确定元素属于哪一个子集。它用来确定两个元素是否属于同一子集。</li><li><code>Union</code>：将两个子集合并成同一个几何。</li></ul><p>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，<code>Find(x)</code> 返回 <code>x</code> 所属集合的代表，而 <code>Union</code> 使用两个集合的代表作为参数。</p><h2 id="并查集介绍和实现"><a href="#并查集介绍和实现" class="headerlink" title="并查集介绍和实现"></a>并查集介绍和实现</h2><p>市场上原来有 $1,2,3,4,5,6$ 这六家公司，各自经营着自己的生意。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/1.png" srcset="/img/loading.gif" alt></p><p>有一天，$4$ 找到了 $1$ 说，最近形式不大好，要不我们两家公司合并成一家，$4$ 觉得自己的名字不够气派，就跟着 $1$ 叫同一个名字了。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/2.png" srcset="/img/loading.gif" alt></p><p>过了不久，$2$ 也想着找人合作，就找到了 $4$，$4$ 说我已经改叫 $1$ 了，你跟我和合作就是跟 $1$ 合作，$2$ 和 $1$ 商量了一下，$2$ 也觉得自己的名字不好听，也改成 $1$ 的名字了。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/3.png" srcset="/img/loading.gif" alt></p><p>$3,6$ 一看市场形势，也开始和 $5$ 商量起了合并的事宜，他们决定最后名字就是 $5$ 了。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/4.png" srcset="/img/loading.gif" alt></p><p>可是 $5$ 合并的太晚了， 已经临近破产，$2$ 公司看到机会跟 $6$ 公司商量事宜，其实最后就是 $1$ 和 $5$ （他们合并后的公司）商量，结果 $5$ 很无奈，被合并了，最后所有公司归为 $1$ 管理了。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/5.png" srcset="/img/loading.gif" alt></p><p>其实这个合并的图是一个<strong>树状结构</strong>，寻找每个集合的代表元素，只要层层向上访问<strong>父节点</strong>搜索即可，直到到达树的<strong>根节点</strong>。根节点的父节点是它自身。我们可以直接把这幅图表示成一棵树。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/6.png" srcset="/img/loading.gif" alt></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>根据上面例子的步骤，我们可以轻松写出简单版本的并查集代码。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code class="hljs c++"><span class="hljs-keyword">int</span> root[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        root[i] = i;&#125;</code></pre><p>我们用 <code>root</code> 数组存储每个节点的父节点， 刚开始，先把所有节点的父节点初始化为自己。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root[x] == x)        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(root[x]);&#125;</code></pre><p>查询这个节点的根节点时，我们使用递归的思想：一层一层访问该节点的父节点，直到访问到根节点（即父节点是自身）。</p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    root[<span class="hljs-built_in">find</span>(i)] = <span class="hljs-built_in">find</span>(j);&#125;</code></pre><p>合并两个节点也很节点，只要把其中一个的根节点的父节点设置为另一个的父节点即可。</p><h2 id="优化并查集"><a href="#优化并查集" class="headerlink" title="优化并查集"></a>优化并查集</h2><p>前面说的简单的并查集其实效率比较低。</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>我们可以看以下场景：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/7.png" srcset="/img/loading.gif" alt></p><p>我们进行 <code>merge(2,3)</code> 和 <code>merge(2,4)</code> 操作后，图变为如下：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/8.png" srcset="/img/loading.gif" alt></p><p>这是一条长链，随着节点的不断增多，这条链会越来越长，我们从链最底部找到其根节点的消耗也越来越多。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/9.png" srcset="/img/loading.gif" alt></p><p>如果图是这样的，我们就不必层层查询根节点了。</p><p>那么怎么实现呢？我们可以使用<strong>路径压缩</strong>的方法，在每次寻找元素根节点的时候，把它的父节点直接设为根节点，这样在下一次查询后，只要一次就能找到根节点了。</p><p>同样用递归的方式，把沿途的父节点全设置为根节点：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (x != root[x])    &#123;        root[x] = <span class="hljs-built_in">find</span>(root[x]);    &#125;    <span class="hljs-keyword">return</span> root[x];&#125;</code></pre><h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>由于路径压缩只对访问过的路径进行压缩，不是每个节点的父节点都是根节点。所以并查集的结构仍然可能是负载的。看下面的情形：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/10.png" srcset="/img/loading.gif" alt></p><p>$8$ 要和 $7$ 合并，这是我们有两种方案，$7$ 作为 $8$ 的父节点和 $8$ 作为 $7$ 的父节点这两种方式：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/13.png" srcset="/img/loading.gif" alt></p><p>显然第一种方式效率更加高。</p><p>因为如果把  $8$ 作为 $7$ 的父节点，会使得数的<strong>深度</strong>（树中最长链的长度）加深，原来树的每个节点到根的距离都变长了，后面我们每次查询根节点复杂度也会变高。而把 $7$ 作为 $8$ 的父节点就不会有这个问题。因此我们每次合并的时候都应该把简单的树合并到复杂的树上面，保证每次合并到根节点距离变长的节点数量最少。</p><p>运用这个思想我们可以写出相关的代码。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>我们用 <code>rank</code> 数组来表示每个根节点对应的树的深度。一开始将所有的 <code>rank</code> 置为 <code>1</code>。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> rank[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        root[i] = i;        rank[i] = <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h4 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a>合并</h4><p>合并时比较两个根节点的 <code>rank</code> 值，将 <code>rank</code> 小的向 <code>rank</code> 大的树合并。如果两个树深度相同，则合并后新树的 <code>rank</code> 值需要加一。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-built_in">find</span>(i), y = <span class="hljs-built_in">find</span>(j);    <span class="hljs-keyword">if</span> (rank[x] &lt;= rank[y])        root[x] = y;   <span class="hljs-keyword">else</span>        root[y] = x;   <span class="hljs-keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)        rank[y]++;&#125;</code></pre><p>注意路径压缩和按秩合并一起使用时，可能会破坏按秩合并的准确性。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra 算法</title>
    <link href="/2020/07/13/Dijkstra/"/>
    <url>/2020/07/13/Dijkstra/</url>
    
    <content type="html"><![CDATA[<p>Dijkstra 算法是一个最短路径算法，常用于解决非负有权图中的最短路径问题。本文通过示例介绍了 Dijkstra 算法，并给出了 C++ 的算法实现和一种优化策略。</p><a id="more"></a><h1 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Dijkstra 算法通过保留目前为止所找到的每个顶点 $v\in V$从 $s$ 到 $v$ 的最短路径来工作的。初始时，起点 $s$ 的路径权重被赋为 $0\ (dis[s]=0)$，同时把其他路径的长度设为无穷大。当算法结束后，$dis[v]$ 存储的便是从 $s$ 到 $v$ 的最短路径，如果路径不存在，则 $dis[v] = \infty $。</p><p>松弛操作是 $Dijkstra$ 算法的基础操作：如果存在一条从 $u$ 到 $v$ 的边，那么从 $s$ 到 $v$ 的一条新路径就是将边 $w(u,v) \in E$ 添加到从 $s$ 到 $u$ 的路径尾部，拓展出一条从 $s$ 到 $u$ 的路径。这条新路径的长度是 $dis[u] + w(u,v)$。如果这个值比已知的 $dis[v]$ 小，那么可以替换原先的 $dis[v]$，并将 $path[v]$ 的值更改为 $u$。松弛操作已知运行到所有的 $d[v]$ 都代表 $s$ 到 $v$ 的最短路径的长度值。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>直接看介绍可能还不理解，我们可以看如下的图</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/1.png" srcset="/img/loading.gif" alt></p><p>假设起点 $s = 1$，我们将 $s$ 压入路径 $q$ 中， $vis[s] = 1(true)$ ,  $dis[s] = 0$，寻找路径中最近的点 $u$ 即 $u=1$ ，将 $u$ 扔出路径，此时 $u$ 点连通 $v = 2,4,6$ 三点，将 $\{2,4,6\}$ 压入路径 $q$ 中，计算 $w = w(u,v)+dis[u]$，根据 $dis[v] = min(dis[v],w)$ 更新 $dis$ ,此时$dis=\{0,2,\infty,6,\infty,9,\infty,\infty,\infty\}$ ,若 $dis[v]$ 更新，就使 $path[v] = w$ ，此时 $path = \{1,1,0,1,0,1,0,0\}$ 。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/2.png" srcset="/img/loading.gif" alt></p><p>第二次，我们查找路径中与起点 $s$ 距离最近的点$u$ ，此时 $u=2$，同样将 $u$ 扔出路径并将 $vis[u]=1$， 因为$u$ 点连通 $v = 3,4$ 且 $vis[v] = 0 (false)$，所以更新路径 $q=\{3,4,6\}$，更新 $dis=\{0,2,32,3,\infty,9,\infty,\infty\} $，更新$path=\{1,1,2,2,0,1,0,0\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/3.png" srcset="/img/loading.gif" alt></p><p>同理，$u=4$，$vis[u]=1$，$q=\{3,5,6\}$，$dis=\{0,2,32,3,5,9,\infty,\infty\}$，$path=\{1,1,2,2,4,1,0,0\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/4.png" srcset="/img/loading.gif" alt></p><p>同理，$u=5$，$vis[u]=1$，$q=\{3,6,7\}$，$dis=\{0,2,13,3,5,9,12,\infty\}$，$path=\{1,1,5,2,4,1,5,0\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/5.png" srcset="/img/loading.gif" alt></p><p>同理，$u=6$，$vis[u]=1$，$q=\{3,7\}$，$dis=\{0,2,13,3,5,9,12,\infty\}$，$path=\{1,1,5,2,4,1,5,0\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/6.png" srcset="/img/loading.gif" alt></p><p>同理，$u=7$，$vis[u]=1$，$q=\{3,8\}$，$dis=\{0,2,13,3,5,9,12,33\}$，$path=\{1,1,5,2,4,1,5,7\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/7.png" srcset="/img/loading.gif" alt></p><p>同理，$u=3$，$vis[u]=1$，$q=\{8\}$，$dis=\{0,2,13,3,7,9,12,28\}$，$path=\{1,1,5,2,4,1,5,3\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/8.png" srcset="/img/loading.gif" alt></p><p>最后$u=5$，$vis[u]=1$，$q=\{\}$ 为空，到此 $Dijkstra$ 算法顺利完成！</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/9.png" srcset="/img/loading.gif" alt></p><h2 id="实现及优化"><a href="#实现及优化" class="headerlink" title="实现及优化"></a>实现及优化</h2><p>首先定义 $dis,vis,path,node$。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> dis[N];<span class="hljs-keyword">bool</span> vis[N];<span class="hljs-keyword">int</span> path[N];stuct node&#123;    <span class="hljs-keyword">int</span> u, v, w;    node(<span class="hljs-keyword">int</span> _u, <span class="hljs-keyword">int</span> _v, <span class="hljs-keyword">int</span> _w):u(_u), v(_v), w(_w)&#123;&#125;    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> node&amp; n) <span class="hljs-keyword">const</span>    &#123;        <span class="hljs-keyword">return</span> v &gt; n.v;    &#125;&#125;;</code></pre><p>初始化 $dis,vis,path$</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        dis[N] = INT_MAX;    &#125;    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-built_in">memset</span>(path,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(path));&#125;</code></pre><p>因为有删除操作，为了减少复杂度，选择了用 <code>std::list&lt;&gt;</code> 来存储路径。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;node&gt;&gt;&amp; vec, <span class="hljs-keyword">int</span> s)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; q;    init();    q.push_back(s);    dis[s] = <span class="hljs-number">0</span>;    path[s] = s;    <span class="hljs-keyword">while</span> (!q.empty())    &#123;        <span class="hljs-keyword">auto</span> k = q.<span class="hljs-built_in">begin</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>(); it != q.<span class="hljs-built_in">end</span>(); it++)        &#123;            <span class="hljs-keyword">if</span> (dis[*it] &lt; dis[*k])                k = it;        &#125;        <span class="hljs-keyword">int</span> v = *k;        q.erase(k);        vis[v] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : vec[v])        &#123;            <span class="hljs-keyword">if</span> (!vis[i.v] &amp;&amp; i.w + dis[v] &lt; dis[i.v])            &#123;                dis[i.v] = i.w + dis[v];                path[i.v] = v;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(q.<span class="hljs-built_in">begin</span>(),q.<span class="hljs-built_in">end</span>(),i.v)==q.<span class="hljs-built_in">end</span>())                    q.push_back(i.v);            &#125;        &#125;    &#125;&#125;</code></pre><p>因为在每次寻找离起点最近的点都要花费 $O(V)$ 的复杂度，所以考虑把点都存在堆中，在 C++ 中一般使用<code>std::priority_queue&lt;&gt;</code>优先队列，将每条边以 $\{u,v,w(u,v)+dis[u]\}$ 的形式压入队列中，队列顶端的元素即为边通向的顶点到起点距离的最小值，此时只要花费 $O(log(E))$ 的复杂度。总体的复杂度从 $O(V^2+E)$ 变为了 $O((E+V)log(E))$，当图为<strong>稀疏图</strong>时，使用堆的算法效率明显更高。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;node&gt;&gt;&amp; vec, <span class="hljs-keyword">int</span> s)</span></span><span class="hljs-function"></span>&#123;    init();    priority_queue&lt;node&gt; q;    q.push(node(s,s,<span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span> (!q.empty())    &#123;        node k = q.top();        q.pop();        <span class="hljs-keyword">if</span>(vis[k.v]) <span class="hljs-keyword">continue</span>;        vis[k.v] = <span class="hljs-literal">true</span>;        dis[k.v] = k.w;        path[k.v] = k.u;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : vec[k.v])        &#123;            q.push(node(i.u, i.v, i.w + dis[i.u]));        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Template-1 函数模板</title>
    <link href="/2020/07/09/cpp-template-1/"/>
    <url>/2020/07/09/cpp-template-1/</url>
    
    <content type="html"><![CDATA[<p>通过大量的例子介绍了C++函数模板。你可以学习到如何使用C++的函数模板以及使用时需要注意的要点。</p><a id="more"></a><p>这是本系列<strong>第一篇</strong>文章，以下是本系列文章目录。</p><p><a href="#1-函数模板">1. 函数模板（本文）</a></p><p><a href>2. 类模板 （正在编写）</a></p><h1 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a>1. 函数模板</h1><p>本章介绍了函数模板。函数模板是被参数化的函数，因此他们代表了一组行为相似的函数(a family of functions)。</p><h2 id="1-1-初识函数模板"><a href="#1-1-初识函数模板" class="headerlink" title="1.1. 初识函数模板"></a>1.1. 初识函数模板</h2><p>函数模板提供了适用于不同类型的函数行为。也就是说，函数模板代表了一组行为相似的函数。函数模板看起来几乎就跟普通函数一样，除了某些信息没有被确定以外。我们通过下面一个简单的例子来说明这一问题。</p><h3 id="1-1-1-定义模板"><a href="#1-1-1-定义模板" class="headerlink" title="1.1.1 定义模板"></a>1.1.1 定义模板</h3><p>一下是一个函数模板，它返回两数中的最大值</p><pre><code class="hljs c++"><span class="hljs-comment">//max1.hpp</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>这个模板第一了一系列函数，他们都返回了两个参数中值较大的拿一个。这两个参数的类型并没有确定，而是被表示为<strong>模板参数(template parameter)</strong> <code>T</code>。</p><p>模板参数应该按照如下的语法来声明：</p><p><em>template &lt;由逗号分隔的模板参数&gt;</em></p><p>在本例中，模板参数是 <code>typename T</code> 。关键字 <code>typename</code> 标识了一个<em>类型参数</em>，即 <code>T</code> 是<strong>类型参数(type parameter)</strong>，你可以用任意的标识作为类型参数的参数名，但是习惯上我们使用 <code>T</code> 作为参数名。本例中，类型 <code>T</code> 必须支持小于运算符，因为 <code>a</code> 和 <code>b</code> 比较时运用到了它。另外比较隐秘的一点，为了支持返回值，<code>T</code> 还应该是可拷贝的。</p><h3 id="1-1-2-使用模板"><a href="#1-1-2-使用模板" class="headerlink" title="1.1.2 使用模板"></a>1.1.2 使用模板</h3><p>下面的程序展现了如何使用 <code>max()</code>模板：</p><pre><code class="hljs c++"><span class="hljs-comment">//max1.cpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"max1.hpp"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(7,i): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>,i) &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">double</span> f1 = <span class="hljs-number">3.4</span>;    <span class="hljs-keyword">double</span> f2 = <span class="hljs-number">-6.7</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(f1,f2): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(f1,f2) &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"mathematics"</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"math"</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(s1,s2): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(s1,s2) &lt;&lt; <span class="hljs-string">'\n'</span>;&#125;</code></pre><p>注意在调用的 <code>max()</code> 模板的时候使用了作用域限制符 <code>::</code>。这样保证了程序将会在全局<strong>命名空间(namespace)</strong>中查找 <code>max()</code> 模板。</p><p>在此程序中，<code>max()</code>被调用了三次：一次是比较两个<code>int</code>，一次是比较两个<code>double</code>，还有一次是比较两个 <code>std::string</code>。每一次都会算出最大值。下面是输出结果：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-number">7</span>,i)</span></span>: <span class="hljs-number">42</span><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(f1,f2)</span></span>: <span class="hljs-number">3.4</span><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(s1,s2)</span></span>: mathematics</code></pre><p>在编译阶段，模板并不是被编译成一个可以支持多种类型的实体。而是对每一个用于该模板的类型都会产生一个独立的实体。因此在本例中，<code>max()</code> 会被编译出三个实体，因为它被用于三种类型。比如第一次调用时：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;... <span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, i) ...</code></pre><p>函数模板的类型参数 T 是<code>int</code>。因此在语义上等价于调用如下函数：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>以上用具体类型取代模板类型参数的过程叫做<strong>实例化(instantiation)</strong>。它会产生模板的一个实例。</p><p>值得注意的是，模板的实例化不需要程序员做额外的请求，只是简单的使用函数模板就会触发这一实例化过程。</p><p>同样的，另外两次调用也会分别为 <code>double</code> 和 <code>std::string</code> 各实例化出一个实例，就像是分别定义了下面两个函数一样：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>)</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>)</span></span>;</code></pre><p>另外，只要结果是有意义的，void 作为模板参数也是有效的。比如:</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">foo</span><span class="hljs-params">(T*)</span></span><span class="hljs-function"></span>&#123; &#125;<span class="hljs-keyword">void</span>* vp = <span class="hljs-literal">nullptr</span>;foo(vp); <span class="hljs-comment">// OK: 模板参数被推导为 void</span>foo(<span class="hljs-keyword">void</span>*)</code></pre><h3 id="1-1-3-二阶段翻译-Two-Phase-Translation"><a href="#1-1-3-二阶段翻译-Two-Phase-Translation" class="headerlink" title="1.1.3 二阶段翻译(Two-Phase Translation)"></a>1.1.3 二阶段翻译(Two-Phase Translation)</h3><p>在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误(compile-time error)。比如：</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">complex</span>&lt;<span class="hljs-keyword">float</span>&gt; c1, c2; <span class="hljs-comment">// std::complex&lt;&gt; 没有提供小于运算符</span>...::<span class="hljs-built_in">max</span>(c1,c2); <span class="hljs-comment">// 编译期 ERROR</span></code></pre><p>在编写是不会立刻提醒错误，因为模板是分两步编译的：</p><ol><li><p>在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面：</p><ul><li>语法检查。比如少了分号。</li><li>检查使用未定义的不依赖于模板参数的未知名称（类型名，函数名，…）。</li><li>检查不依赖于模板参数的<strong>静态断言(static assertion)</strong>；</li></ul></li><li><p>在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。</p><p>例如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span><span class="hljs-function"></span>&#123;    undeclared(); <span class="hljs-comment">// 如果 undeclared() 未定义，第一阶段就会报错</span>    undeclared(t); <span class="hljs-comment">//如果 undeclared(t) 未定义，第二阶段会报错</span>    <span class="hljs-keyword">static_assert</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &gt; <span class="hljs-number">10</span>,<span class="hljs-string">"int too small"</span>); <span class="hljs-comment">// 总是报错</span>    <span class="hljs-keyword">static_assert</span>(<span class="hljs-keyword">sizeof</span>(T) &gt; <span class="hljs-number">10</span>, <span class="hljs-string">"T too small"</span>); <span class="hljs-comment">//只会在第二阶段报错</span>&#125;</code></pre></li></ol><p>需要注意的是，有些编译器并不会执行第一阶段中的所有检查。因此如果模板没有被至少实例化一次的话，你可能一直都不会发现代码中的常规错误。</p><h4 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h4><p>两阶段的编译检查给模板的处理带来了一个问题：当实例化一个模板的时候，编译器需要（一定程度上）看到模板的完整定义。这不同于函数编译和链接分离的思想，函数在编译阶段只需要声明就够了。后面将讨论如何应对这一问题。现在暂时采取最简单的方法：将模板的实现写在头文件里。</p><h2 id="1-2-模板参数推导"><a href="#1-2-模板参数推导" class="headerlink" title="1.2. 模板参数推导"></a>1.2. 模板参数推导</h2><p>当我们调用形如 <code>max()</code> 的函数模板来处理某些变量时，模板参数将由被传递的调用参数决定。如果我们传递两个 <code>int</code> 类型的参数给模板函数，C++编译器会将模板参数 T 推导为 <code>int</code>。</p><p>不过 T 可能只是实际传递的函数参数类型的一部分。比如我们定义了如下接受常量引用作为函数参数的模板：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; a, T <span class="hljs-keyword">const</span>&amp; b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>此时如果我们传递 <code>int</code> 类型的调用参数，由于调用参数和 <code>int const &amp;</code> 匹配，类型参数 T 将被推导为<code>int</code>。</p><h3 id="1-2-1-类型推导中的类型转换"><a href="#1-2-1-类型推导中的类型转换" class="headerlink" title="1.2.1 类型推导中的类型转换"></a>1.2.1 类型推导中的类型转换</h3><p>在类型推导的时候自动的类型转换是受限制的：</p><ul><li>如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的两个参数，它们实参的类型必须完全一样。</li><li>如果调用参数是按值传递的，那么只有<strong>退化(decay)</strong>这一类简单转换是被允许的：<code>const</code> 和 <code>volatile</code> 限制符会被忽略，引用被转换成被引用的类型，<strong>数组(raw array)</strong>和函数被转换为相应的指针类型。通过模板类型参数 T 定义的两个参数，它们实参的类型在退化后必须一样。</li></ul><p>例如：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>;...<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> c = <span class="hljs-number">42</span>;max(i, c); <span class="hljs-comment">// OK: T 被推导为 int</span>max(c, c); <span class="hljs-comment">// OK: T 被推导为 int</span><span class="hljs-keyword">int</span>&amp; ir = i;max(i, ir); <span class="hljs-comment">// OK: T 被推导为 int</span><span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>];max(&amp;i, arr); <span class="hljs-comment">// OK: T 被推导为 int*</span></code></pre><p>但是像下面这样是错误的：</p><pre><code class="hljs c++"><span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// ERROR: 不确定 T 该被推导为 int 还是 double</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<span class="hljs-built_in">max</span>(<span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">//ERROR: 不确定 T 该被推导为 const[6] 还是 std::string</span></code></pre><p>有三种办法解决以上错误：</p><ol><li><p>对参数进行类型转换，使参数同时匹配。</p><pre><code class="hljs c++"><span class="hljs-built_in">max</span>(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>), <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK</span></code></pre></li><li><p>显示地指出T的类型取阻止编译器进行类型推导。</p><pre><code class="hljs c++"><span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK</span></code></pre></li><li><p>指明参数可能有多个不同的类型（使用多个模板参数）。</p></li></ol><h3 id="1-2-2-对默认参数的类型推导"><a href="#1-2-2-对默认参数的类型推导" class="headerlink" title="1.2.2 对默认参数的类型推导"></a>1.2.2 对默认参数的类型推导</h3><p>需要注意的是，类型推导并不适用于默认参数。例如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T = <span class="hljs-string">""</span>)</span></span>;...f(<span class="hljs-number">1</span>); <span class="hljs-comment">// OK: T 被推导为 int，调用 f&lt;int&gt; (1)</span>f(); <span class="hljs-comment">// ERROR: 无法推导 T 的类型</span></code></pre><p>为应对这一情况，你需要给模板类型参数也声明一个默认参数</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;<span class="hljs-keyword">void</span> f(T = <span class="hljs-string">""</span>);...f(); <span class="hljs-comment">// OK</span></code></pre><h2 id="1-3-多模板参数"><a href="#1-3-多模板参数" class="headerlink" title="1.3. 多模板参数"></a>1.3. 多模板参数</h2><p>目前我们看到与函数模板有关的两组参数：</p><ol><li><p><strong>模板参数(template parameters)</strong>，定义在函数模板前的尖括号中：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// T 是模板参数</span></code></pre></li><li><p><strong>调用参数(call parameters)</strong>，定义在函数模板名称后的圆括号中：</p><pre><code class="hljs c++"><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> <span class="hljs-comment">// a 和 b 是调用参数</span></span></code></pre></li></ol><p>模板参数可以是一个或者多个。比如，你可以定义这样一个 <code>max()</code> 模板，它可能接受两个不同类型的调用参数：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function">T1 <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;...<span class="hljs-keyword">auto</span> m = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK, 但是返回类型是第一个模板参数 T1 的类型</span></code></pre><p>看上去如你所愿，它是可以接受两个不同类型的调用参数。但是，这也导致了一个问题。如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地一样，当应该返回另一个类型的值的时候，返回值会被做类型转换。这将导致返回值的具体类型和参数的传递顺序有关。如果传递 <code>66.66</code> 和 <code>42</code> 给这个函数模板，返回值是 <code>double</code> 类型的 <code>66.66</code>，但是如果传递 <code>42</code> 和 <code>66.66</code>，返回值却是 <code>int</code> 类型的 <code>66</code>。</p><p>C++提供了多种方法来解决这一问题：</p><ol><li>引入第三个模板参数作为返回类型。</li><li>让编译器找出返回类型</li><li>将返回类型定义为两个参数类型的<strong>公共类型(common type)</strong>。</li></ol><h3 id="1-3-1-返回类型的模板参数"><a href="#1-3-1-返回类型的模板参数" class="headerlink" title="1.3.1 返回类型的模板参数"></a>1.3.1 返回类型的模板参数</h3><p>我们可以像调用普通函数一样条用函数模板，也可以显式地指出模板参数的参数类型。</p><p>当模板参数和调用参数直接没有必然联系，且模板参数不能确定是，就要显式地指明模板参数。例如，你可以引入第三个模板参数来指定函数模板的返回类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> RT&gt;<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;</code></pre><p>但是模板类型推导不会考虑返回类型，而 <code>RT</code> 不是函数的调用参数的类型。因此 <code>RT</code> 不会被推导。这样就必须显式的指明模板参数的类型。比如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> RT&gt;<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;...::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">double</span>,<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK, 但是太繁琐</span></code></pre><p>到目前为止，我们看到的情况是，要么所有模板参数都被显式指定，要么一个都不指定。另一种办法是只指定第一个模板参数的类型，其余参数的类型通过推导获得。通常而言，我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推导出来为止。因此，如果你改变了上面例子中的模板参数顺序，调用时只需要指定返回值的类型就可以了：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;...::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>) <span class="hljs-comment">//OK: 返回类型是 double，T1 和 T2 根据调用参数推导</span></code></pre><p>在本例中，调用 <code>max&lt;double&gt;</code> 时，显式的指明了 <code>RT</code> 的类型是 <code>double</code>，<code>T1</code> 和 <code>T2</code> 则基于传入调用参数的类型被推导为 <code>int</code> 和 <code>double</code>。<br>然而改进版的 <code>max()</code> 并没有带来显著的变化。使用单模板参数的版本，即使传入的两个调用参数的类型不同，你依然可以显式的指定模板参数类型（也作为返回类型）。因此为了简洁，我们最好还是使用单模板参数的版本。</p><h3 id="1-3-2-推导返回类型"><a href="#1-3-2-推导返回类型" class="headerlink" title="1.3.2 推导返回类型"></a>1.3.2 推导返回类型</h3><p>如果返回类型是由模板参数决定的，那么推导返回类型最简单也是<strong>最好的</strong>办法就是让编译器来做这件事。C++14 开始，这成为可能，而且不需要把返回类型声明为任何模板参数类型（不过你需要声明返回类型为 <code>auto</code>）：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>在 C++14 之前，要想让编译器推导出返回类型，就必须让或多或少的函数实现成为函数声明的一部分。在 C++11 中，<strong>尾置返回类型(trailing return type)</strong>允许我们使用函数的调用参数。也就是说，我们可以基于运算符 <code>?:</code> 的结果声明返回类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>在这里，返回类型是由运算符<code>?:</code>的结果决定的，这虽然复杂但是可以得到想要的结果。</p><p>需要注意的是</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b);</code></pre><p>是一个声明，编译器在编译阶段会根据  <code>?:</code>  调用参数 <code>a</code> 和 <code>b</code> 的返回结果来决定实际的返回类型。不过具体实现时不一定需要匹配。所以事实上只要使用 <code>true</code> 作为运算符 <code>?:</code> 的条件就行了：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;auto max(T1 a, T2 b) -&gt; decltype(true ? a : b);</code></pre><p>但是在某些情况下会有一个严重的问题：由于 <code>T</code> 可能是引用类型，返回类型就也可能被推导为引用类型。因此你应该返回的是<strong>退化(decay)</strong>后的 <code>T</code>，像下面这样：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>这里用到了 <em>type trait</em> <code>std::decay&lt;&gt;</code>，它的 <code>type</code> 成员返回目标类型，它定义在标准库 <code>&lt;type_traits&gt;</code> 中。因为其 <code>type</code> 成员是结果类型，为了获取其结果，应该用关键字 <code>typename</code> 来修饰这个表达式。</p><p>注意，在初始化 <code>auto</code> 类型是总是<strong>退化(decay)</strong>后的类型。它同样支持返回类型是 <code>auto</code>。 用 <code>auto</code> 作为返回结果的效果就像下面那样，<code>a</code> 的类型被推导为 <code>i</code> 退化后的类型，即为 <code>int</code>：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span>&amp; ir = i; <span class="hljs-comment">// ir 是 i 的引用</span><span class="hljs-keyword">auto</span> a = ir; <span class="hljs-comment">// a 的类型是 ir decay 之后的类型，也就是int</span></code></pre><h3 id="1-3-3-作为通用类型返回"><a href="#1-3-3-作为通用类型返回" class="headerlink" title="1.3.3 作为通用类型返回"></a>1.3.3 作为通用类型返回</h3><p>从C++11 开始，标准库提供了一种指定“更一般类型”的方式。<code>std::common_type&lt;&gt;::type</code> 产生的类型是他的两个（或更多）模板参数的公共类型。比如：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;std::common_type_t&lt;T1, T2&gt; max(T1 a, T2 b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>同样的，<code>std::common_type&lt;&gt;</code> 也是一个 <em>type trait</em>，定义在标准库 <code>type_traits</code> 中，它返回一个结构体，其 <code>type</code> 成员是结果类型。其主要的应用如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::common_type&lt;T1, T2&gt;::type <span class="hljs-comment">//since C++11</span></code></pre><p>在C++14后，你可以简化其用法，仅需在后面加一个 <code>_t</code>，就可以省掉 <code>typename</code> 和 <code>::type</code>，简化后的版本变为：</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">common_type_t</span>&lt;T1, T2&gt; <span class="hljs-comment">// equivalent since C++14</span></code></pre><p><code>std::common_type&lt;&gt;</code> 的实现用到了一些比较取巧的模板编程手法（后续会介绍）。它根据运算符 <code>?:</code> 的语法规则或者对某些类型的特化来决定目标类型。因此 <code>::max(4, 7.2)</code> 和 <code>::max(7.2, 4)</code> 都返回 <code>double</code> 类型的 <code>7.2</code>。需要注意的是，<code>std::common_type&lt;&gt;</code>的结果也是<strong>退化(decay)</strong>的。</p><h2 id="1-4-缺省模板参数-Default-Template-Arguments"><a href="#1-4-缺省模板参数-Default-Template-Arguments" class="headerlink" title="1.4. 缺省模板参数(Default Template Arguments)"></a>1.4. 缺省模板参数(Default Template Arguments)</h2><p>你也可以给函数模板参数指定一个默认值。这些默认值被称为<strong>缺省模板参数(default template arguments)</strong>【也称为默认模板参数】并且可以用在任何类型的模板中。它们甚至可以通过前面的模板参数来决定自己的类型。</p><p>例如，如果你想像前面叙述的那样是返回类型有多个模板参数，你可以定义一个模板参数 <code>RT</code>，并将其默认类型声明为其他两个模板的公共类型。同样的我们也有多种实现方法：</p><ol><li><p>可以直接使用 <code>?:</code> 运算符。不过由于我们必须在<strong>调用参数(call parameters)</strong> <code>a</code> 和 <code>b</code> 被声明之前使用运算符 <code>?:</code>，我们只能用它们的类型：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2,<span class="hljs-keyword">typename</span> RT =           <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-literal">true</span> ? T1() : T2())&gt;&gt;RT <span class="hljs-built_in">max</span>(T1 a, T2 b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>请注意我们使用了 <code>std::decay_t&lt;&gt;</code> 来确保返回的类型不是引用类型。</p><p>同样值得注意的是，这一实现方法要求我们能够调用两个模板参数的<strong>默认构造(default constructor)</strong>。还有另一种方法，使用 <code>std::declval</code>，不过这将使得声明部分更加复杂，以后我们会讲到。</p></li><li><p>我们同样可以使用 <em>type trait</em> <code>std::decay_t&lt;&gt;</code> 作为返回类型的默认值：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2,          <span class="hljs-keyword">typename</span> RT = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">common_type_t</span>&lt;T1, T2&gt;&gt;RT <span class="hljs-built_in">max</span>(T1 a, T2 b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>在这里<code>std::common_type_t&lt;&gt;</code> 也是会做退化的，因此返回类型不会是引用。</p></li></ol><p>在以上两种情况下，你可以使用 <code>RT</code> 的默认值作为返回类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>);</code></pre><p>也可以显式地指出所有的函数模板参数的类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> b = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7.2</span>, <span class="hljs-number">4</span>);</code></pre><p>但是，我们再次遇到这样一个问题：为了显式指出返回类型，我们必须显式的指出全部三个模板参数的类型。因此我们希望能够将返回类型作为第一个模板参数，并且依然能够从其它两个模板参数推断出它的类型。</p><p>原则上这是可行的，即使后面的模板参数没有默认值，我们依然可以让第一个模板参数有默认值：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT = <span class="hljs-keyword">long</span>, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;RT <span class="hljs-built_in">max</span>(T1 a, T2 b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>基于这个定义，你可以这样调用：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">long</span> l;...<span class="hljs-built_in">max</span>(i, l);     <span class="hljs-comment">// 返回值类型是long (RT 的默认值)</span><span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">//返回int，因为其被显式指定</span></code></pre><p>但是只有当模板参数具有一个“天生的”默认值时，这才有意义。我们真正想要的是从前面的模板参数推导出想要的默认值。原则是这也是可行的（后续会讨论到），但是他是基于类型萃取的，并且会使定义变得更加复杂。</p><p>基于以上原因，最好也是最简单的办法就是像<a href="#推导返回类型">前面讨论的那样</a>让编译器来推断出返回类型。</p><h2 id="1-5-重载函数模板"><a href="#1-5-重载函数模板" class="headerlink" title="1.5. 重载函数模板"></a>1.5. 重载函数模板</h2><p>像普通函数一样，模板也是可以重载的。也就是说，你可以定义多个有相同函数名的函数，当实际调用的时候，由C++编译器负责决定具体该调用哪一个函数。</p><p>下列程序展示了函数模板的重载：</p><pre><code class="hljs c++"><span class="hljs-comment">// maximum of two int values:</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125; <span class="hljs-comment">// maximum of two values of any type:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);         <span class="hljs-comment">// 调用非模板函数</span>    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7.0</span>, <span class="hljs-number">42.0</span>);     <span class="hljs-comment">// 调用 max&lt;double&gt; (通过类型推导)</span>    ::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);      <span class="hljs-comment">//调用 max&lt;char&gt; (通过类型推导)</span>    ::<span class="hljs-built_in">max</span>&lt;&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);       <span class="hljs-comment">// 调用 max&lt;int&gt; (通过类型推导)</span>    ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// 调用 max&lt;double&gt; (无类型推导)</span>    ::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">42.7</span>);     <span class="hljs-comment">//调用非模板函数</span>&#125;</code></pre><p>这个例子展示了一个非模板函数可以与其同名的函数模板共存，并且这个函数模板可以被实例化与非模板函数具有相同类型的调用函数。在其他因素相同时，模板解析过程<strong>优先选择</strong>非模板函数，而不是模板实例化出来的函数。第一个调用就属于这种情况：</p><pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">//两个 int 变量都完美匹配了非模板函数</span></code></pre><p>如果模板可以实例化出一个更匹配的函数，那么就会选择这个模板。如第二和第三次调用 <code>max()</code> 时：</p><pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-number">7.0</span>, <span class="hljs-number">42.0</span>);     <span class="hljs-comment">// 调用 max&lt;double&gt; (通过类型推导)</span>::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);      <span class="hljs-comment">//调用 max&lt;char&gt; (通过类型推导)</span></code></pre><p>在此模板更加匹配，因为它不需要把 <code>double</code> 和 <code>char</code> 转换为 <code>int</code>。</p><p>也可以显式指定一个空的模板列表。这表明它会被解析成一个模板调用，其所有的模板参数会被通过调用参数推断出来：</p><pre><code class="hljs c++">::<span class="hljs-built_in">max</span>&lt;&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);       <span class="hljs-comment">// 调用 max&lt;int&gt; (通过类型推导)</span></code></pre><p>由于在模板参数推断时<strong>不允许</strong>自动类型转换，而常规函数是允许的，因此最后一个调用会选择非模板参函数（ <code>a</code> 和 <code>42.7</code> 都被转换成 <code>int</code>）：</p><pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">42.7</span>);     <span class="hljs-comment">//只有非模板函数允许 nontrivial conversion</span></code></pre><p>一个有趣的例子是我们可以专门为 <code>max()</code> 显示指定其返回值类型的模板来进行重载：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>现在我们可以向这样调用 <code>max()</code>:</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// 调用第一个函数模板</span><span class="hljs-keyword">auto</span> b = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7.2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 调用用第二个函数模板</span></code></pre><p>但是想下面这样调用的话：</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> c = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">//ERROR: 两个函数模板同时匹配</span></code></pre><p>两个模板都是匹配的，这会导致模板解析过程不知道该调用哪一个模板，从而导致未知错误。因此当重载函数模板的时候，要保证对任意一个调用，都只会有一个模板匹配。</p><p>一个比较有用的例子是为指针和 <code>C-strings</code> 重载 <code>max()</code> 模板：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-comment">// maximum of two values of any type:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-comment">// maximum of two pointers:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T *<span class="hljs-title">max</span><span class="hljs-params">(T *a, T *b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> *b &lt; *a ? a : b;&#125;<span class="hljs-comment">// maximum of two C -strings :</span><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *a, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strcmp</span>(b, a) &lt; <span class="hljs-number">0</span> ? a : b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">42</span>;    <span class="hljs-keyword">auto</span> m1 = ::<span class="hljs-built_in">max</span>(a, b); <span class="hljs-comment">// max() for two values of type int</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"hey"</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"you"</span>;    <span class="hljs-keyword">auto</span> m2 = ::<span class="hljs-built_in">max</span>(s1, s2); <span class="hljs-comment">// max() for two values of type std::string</span>        <span class="hljs-keyword">int</span> *p1 = &amp;b;    <span class="hljs-keyword">int</span> *p2 = &amp;a;    <span class="hljs-keyword">auto</span> m3 = ::<span class="hljs-built_in">max</span>(p1, p2); <span class="hljs-comment">// max() for two pointers</span>    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *x = <span class="hljs-string">"hello"</span>;    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *y = <span class="hljs-string">"world"</span>;    <span class="hljs-keyword">auto</span> m4 = ::<span class="hljs-built_in">max</span>(x, y); <span class="hljs-comment">// max() for two C-strings</span>&#125;</code></pre><p>注意上面所有 <code>max()</code> 的重载模板中，调用参数都是按<strong>值</strong>传递的。通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。否则，可能会遇到意想不到的问题。比如，如果你实现了一个按引用传递的 <code>max()</code> 模板，然后又重载了一个按值传递两个 C 字符串作为参数的模板，你不能用接受三个参数的模板来计算三个 C 字符串的最大值：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-comment">// maximum of two values of any type (call-by-reference)</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;a, T <span class="hljs-keyword">const</span> &amp;b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-comment">// maximum of two C-strings (call-by-value)</span><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *a, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strcmp</span>(b, a) &lt; <span class="hljs-number">0</span> ? a : b;&#125;<span class="hljs-comment">// maximum of three values of any type (call-by-reference)</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;a, T <span class="hljs-keyword">const</span> &amp;b, T <span class="hljs-keyword">const</span> &amp;c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c); <span class="hljs-comment">// error if max(a,b) uses call-by-value</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">auto</span> m1 = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>, <span class="hljs-number">68</span>); <span class="hljs-comment">// OK</span>        <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s1 = <span class="hljs-string">"frederic"</span>;    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s2 = <span class="hljs-string">"anica"</span>;    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s3 = <span class="hljs-string">"lucas"</span>;    <span class="hljs-keyword">auto</span> m2 = ::<span class="hljs-built_in">max</span>(s1, s2, s3); <span class="hljs-comment">//run-time ERROR</span>&#125;</code></pre><p>问题在于当用三个 C 字符串作为参数调用 <code>max()</code> 的时候，</p><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c);</code></pre><p>会遇到run-time error，这是因为对C 字符串，<code>max(max(a, b), c)</code> 会创建一个用于返回的临时局部变量，而在返回语句接受后，这个临时变量会被销毁，导致 <code>max()</code> 使用了一个悬空的引用。不幸的是，这个错误几乎在所有情况下都不太容易被发现。</p><p>作为对比，在求三个 <code>int</code> 最大值的 <code>max()</code> 调用中，则不会遇到这个问题。这里虽然也会创建三个临时变量，但是这三个临时变量创建在 <code>main()</code> 中，它们的存在时间会持续到语句结束。</p><p>这只是模板解析与期望结果不一致的一个例子。另外，要确保函数模板在调用前已经被定义。这是由于我们调用某个函数模板时，不是所有的重载函数都是可见的。比如我们定义了三个参数的 <code>max()</code> 函数，由于它调用适用于两个 <code>int</code> 类型的 <code>max()</code> 时，重载的两个 <code>int</code> 类型的 <code>max()</code> 是不可见的，因此它最终会调用两个参数的模板函数：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// maximum of two values of any type:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max&lt;T&gt;() \n"</span>;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125; <span class="hljs-comment">// maximum of three values of any type:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b, T c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c); <span class="hljs-comment">//仍然使用函数模板</span>   <span class="hljs-comment">//因为重载的声明在后面</span>&#125;<span class="hljs-comment">// maximum of two int values:</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(int,int) \n"</span>;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">47</span>, <span class="hljs-number">11</span>, <span class="hljs-number">33</span>);     <span class="hljs-comment">// OOPS: uses max&lt;T&gt;() instead of max(int,int)</span>&#125;</code></pre><h2 id="1-6-但是，不应该使用？"><a href="#1-6-但是，不应该使用？" class="headerlink" title="1.6. 但是，不应该使用？"></a>1.6. 但是，不应该使用？</h2><h3 id="1-6-1-按值传递还是按应用传递？"><a href="#1-6-1-按值传递还是按应用传递？" class="headerlink" title="1.6.1 按值传递还是按应用传递？"></a>1.6.1 按值传递还是按应用传递？</h3><p>我们声明的函数通常都是按值传递，而不是按引用传递。通常而言，建议将按引用传递除简单类型（比如<strong>基础类型(fundamental type)</strong>和 <code>std::string_view</code>）以外的类型，这样可以免除不必要的拷贝成本。</p><p>但是出于以下原因，<strong>按值传递</strong>通常更好一些：</p><ul><li>语法简单。</li><li>编译器优化更好。</li><li>移动语意是的拷贝成本较低。</li><li>某些情况下没有拷贝或者移动。</li></ul><p>再有，对于模板，还有一些特殊情况：</p><ul><li>模板可能用于简单类型也可能由于复杂类型，因此如果选择利于复杂类型的方式，可能会对简单类型产生不利的影响。</li><li>作为调用者，你可以通过使用 <code>std::ref()</code> 和 <code>std::cref()</code> 决定是否按照引用传递参数。</li><li>尽管传递 <em>string literal</em> 和 <em>raw array</em> 会产生一些问题，按时如果按照引用传递它们会产生更大的问题。</li></ul><p>后续会对此进行进一步讨论，<strong>除了某些不得不用按引用传递的情况，尽量使用按值传递。</strong></p><h3 id="1-6-2-为什么不用-inline？"><a href="#1-6-2-为什么不用-inline？" class="headerlink" title="1.6.2 为什么不用 inline？"></a>1.6.2 为什么不用 inline？</h3><p>通常，函数模板不需要声明为 <code>inline</code>。不像普通的 <code>noninline</code> 函数，我们可以把 <code>noninline</code> 函数模板定义在同文件中，然后再多个编译单元里 <code>include</code> 这个头文件。</p><p>唯一一个例外是模板对某些类型进行了<strong>全特化(full spcializations)</strong>，这时的结果代码不再是<strong>泛型(generic)</strong>的(所有的模板参数都已经被指定了)。后续会详细讨论。</p><p>严格地从语言角度来看，<code>inline</code> 只意味着在程序中函数的定义可以出现很多次。不过它也给了编译器一个暗示，在调用该函数的地方函数应该被展开成 <code>inline</code> 的：这样做在某些情况下可以提高效率，但是在另一些情况下也可能降低效率。现代编译器在没有关键字 <code>inline</code> 暗示的情况下，通常也可以很好的决定是否将函数展开成 <code>inline</code> 的。当然，编译器在做决定的时候依然会将关键字 <code>inline</code> 纳入考虑因素。</p><h3 id="1-6-3-为什么不用-constexpr？"><a href="#1-6-3-为什么不用-constexpr？" class="headerlink" title="1.6.3 为什么不用 constexpr？"></a>1.6.3 为什么不用 constexpr？</h3><p>从 C++11 开始，你可以通过关键字 <code>constexpr</code> 来在编译期进行某些运算。对于很多模板来说，这是有意义的。</p><p>比如为了可以在编译期使用求最大值的函数，你需要将函数模板定义如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>通过此，你可以使用此函数在编译期就求出最大值，例如当定义数列的大小时：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">1000u</span>)];</code></pre><p>或者指定 <code>std::array&lt;&gt;</code> 的大小：</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, ::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), 1000u)&gt; arr;</code></pre><p>在这里我们传递的 1000 是 <code>unsigned int</code> 类型，这样可以避免直接比较一个有符号数值和一个无符号数值时产生的警报。</p><p>后续也会继续讨论 <code>constexpr</code>。</p><h2 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7. 小结"></a>1.7. 小结</h2><ul><li>函数模板定义了一组适用于不同类型的函数</li><li>当向模板函数传递变量时，函数模板会自行推导模板参数的类型，来决定去实例化出那种类型的函数。</li><li>你也可以显式的指出模板参数的类型。</li><li>你可以定义模板参数的默认值。这个默认值可以使用该模板参数前面的模板参数的类型，而且其后面的模板参数可以没有默认值。</li><li>函数模板可以被重载。</li><li>当定义新的函数模板来重载已有的函数模板时，必须要确保在任何调用情况下都只有一个模板是最匹配的。</li><li>当你重载函数模板的时候，最好只是显式地指出了模板参数的类型。</li><li>确保在调用某个函数模板之前，编译器已经看到了相对应的模板定义。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Template</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-2.1 信息表示和处理-信息储存</title>
    <link href="/2020/07/07/CSAPP_2_1/"/>
    <url>/2020/07/07/CSAPP_2_1/</url>
    
    <content type="html"><![CDATA[<p>简述了计算机信息的储存方式、十六进制表示法，布尔代数和C语言中的位运算、逻辑运算和移位操作三类运算符。</p><a id="more"></a><h2 id="2-1-信息储存"><a href="#2-1-信息储存" class="headerlink" title="2.1 信息储存"></a>2.1 信息储存</h2><p>​        大多数计算机使用8位的块，或者<strong>字节(byte)</strong>，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级的程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存(virtual memory)</strong>。内存的每个字节都由一个唯一的数字来标识，称为它的<strong>地址(address)</strong>，所有可能的地址的集合就称为<strong>虚拟地址空间(virtual address space)。</strong>虚拟地址空间只是一个展现给机器级程序的概念性映像，实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。</p><h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>​        一个字节有8位组成。在二进制表示法中，它的值域是$00000000_2\sim 11111111_2$。如果看成十进制整数，它的值域就是$0_{10}\sim255_{10}$。两种符合表示法对于表述位模式都不是很方便所以引入了<strong>十六进制(hexadecimal)</strong>表示法。用十六进制书写，一个字节的值域为$00_{16}\sim FF_{16}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-2-1/1.png" srcset="/img/loading.gif" alt="十六进制表示法"></p><p>​        在C语言中，以 <code>0x</code>或 <code>0X</code>开头的数字常量为被认为是十六进制的值。</p><h3 id="字数据的大小"><a href="#字数据的大小" class="headerlink" title="字数据的大小"></a>字数据的大小</h3><p>​        每台计算机都有一个<strong>字长(word size)</strong>，指明指针数据的标称大小(nominal size)。因为，虚拟地址是以这样的一个字节来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 $w$位对的机器而言，虚拟地址的范围为$0$~$2^w-1$，程序最多访问$2^w$个字节。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-2-1/2.png" srcset="/img/loading.gif" alt="基本C数据类型的典型大小"></p><h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>​        对于跨越多字节的程序对象，我们必须建立两个原则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。</p><p>​        排列表示一个对象的字节有两个通用的规则。考虑一个$w$位的整数，其位表示为$[x_{w-1},x_{w-2},···，x_1,x_0]$，其中$x_{w-1}$是最高有效位，而$x_0$是最低有效位。假设$w$是8的倍数，这些为就能被分组成为字节，其中最高有效字节包含位$[x_{w-1},x_{w-2},···,x_{w-8}]$，而最低有效字节包含位$[x_7,x_6,x_5,x_4,x_3,x_2,x_1,x_0]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节的顺序储存。前一种规则——最低有效字节在最前面的方式，称为<strong>小端法(little endian)</strong>。后一种规则——最高有效字节在最前面的方式，称为<strong>大端法(big endian)</strong>。</p><p>​        假设变量 x的类型为 <code>int</code>，位于地址 <code>0x100</code>处，它的十六进制值为 <code>0x01234567</code>。地址范围<code>0x100</code>~<code>0x103</code>的字节顺序依赖于机器的类型：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-2-1/3.png" srcset="/img/loading.gif" alt="大端法和小端法"></p><p>​        对于大多数应用程序员来说，其机器所使用的的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据是，一个常见的问题是当小端法机器及其产生的数据被发送到大端法机器（或者反过来），接受程序会发现，字里的字节成了反序的，为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换为网络标准，而接收方则将网络标准转换为它的内部表示。</p><p>第二种情况是，当阅读表示证书数据的字节序列是字节顺序也很重要。</p><p>第三种情况是，当编写规避正常的类型的程序时，字节顺序很重要。在C语言中，可以通过<strong>强制类型转换(cast)</strong>或<strong>联合(union)</strong>来允许以一种数据类型引用对象，而这种数据类型与创建这个对象是定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是他们对系统级编程来说是非常有用，甚至是必需的。</p><h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>​        C语言中字符串被编码为一个以<code>null</code>（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符吗。字符串在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。</p><h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><p>​        不同的及其类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p><p>​        计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始程序的任何信息，除了可能有些用来帮助调试的辅助表以外。</p><h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><p>​        二进制是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经演化出了丰富的数学知识体系。</p><p>​        最简单的布尔代数实在二元集合${0,1}$基础上的定义，布尔运算  $\sim$ 对应于逻辑运算 NOT，在命题逻辑中用符号 $\neg$ 表示。也就是说，$P$ 不为真时，$\neg P$ 为真，反之亦然。 相应地， 当 $P$ 等于0时，$\sim P$ 等于 1，反之亦然。布尔运算 $\&amp;$ 对应于逻辑运算 AND， 在命题逻辑中用符号 $\wedge$ 表示。当 $P$ 和 $Q$ 都为真时，我们说 $P\wedge Q$ 为真。相应的，只有当 $p=1$ 且 $q=1$ 时，$p\&amp; q$ 才等于1。布尔运算 $|$ 对应与逻辑运算 OR， 在命题逻辑中用符号 $\vee$ 表示。 当 $P$ 或者 $Q$ 为真时，我们说 $ P\vee Q$ 成立。相应地，当 $p=1$ 或者 $q=1$ 时，$p| q$ 等于1。布尔运算 $\hat{}$ 对应逻辑运算异或，在命题逻辑中用符号 $\oplus$ 表示。 当 $P$ 或者 $Q$ 为真但不同时为真时，我们说 $ P\oplus Q$ 成立。当 $p=1$ 且 $q=0$，或者 $p=0$ 且 $q=1$， $p\hat{} q$ 等于1。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-2-1/4.png" srcset="/img/loading.gif" alt="布尔代数的运算"></p><p>我们可以将上述4个布尔运算扩展到<strong>位向量</strong>的运算，位向量就是固定长度为$w$、由0和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。假设 $a$ 和 $b$ 分别表示位向量 $[a_{w-1},a_{w-2},···,a_0]$ 和 $[b_{w-1},b_{w-2},···,b_0]$。 我们将 $a\&amp;b$ 也定义为一个长度为 $w$ 的位向量，其中第 $i$ 个元素等于 $a_i\&amp; b_i$，$0\leqslant i &lt; w$。可以用类似的方式将运算 $|$ 、$\hat{}$ 和 $\sim$ 拓展到位运算上。</p><p>位向量是一个很有用的应有就是表示有限集合。我们可以用位向量 $[a_{w-1},a_{w-2},···,a_0]$ 编码任何子集 $A\subseteq {0,1,···,w-1 }$，其中 $a_i = 1$ 当且仅当 $i\in{A}$。</p><h3 id="C语言中的位级运算"><a href="#C语言中的位级运算" class="headerlink" title="C语言中的位级运算"></a>C语言中的位级运算</h3><p>​        C语言的布尔运算符号：<code>|</code> OR（或），<code>&amp;</code>  AND（与），<code>~</code> NOT（取反），<code>^</code> EXCLUSIVE-OR（异或）。</p><h3 id="C语言中的逻辑运算"><a href="#C语言中的逻辑运算" class="headerlink" title="C语言中的逻辑运算"></a>C语言中的逻辑运算</h3><p>​        C语言的逻辑运算符号<code>||</code>、<code>&amp;&amp;</code>、<code>!</code>，分别对应命题逻辑中的OR、AND 和 NOT。</p><h3 id="C语言中的移位操作"><a href="#C语言中的移位操作" class="headerlink" title="C语言中的移位操作"></a>C语言中的移位操作</h3><p>​        C语言提供了一组移位运算符<code>&lt;&lt;</code>、<code>&gt;&gt;</code>，向左或者向右移位模式。对于左移<code>x &lt;&lt; k</code>来说，x 向左移动 $k$ 位，并在右端补 $k$ 个 0。对于右移<code>x &gt;&gt; k</code>来说，机器支持两种形式的右移：<strong>逻辑右移</strong>和<strong>算术右移</strong>。逻辑右移就是在左端补 $k$ 个 0。算术右移是在左端补 $k$ 个最高有效位的值。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Virtual Function</title>
    <link href="/2020/07/07/cpp_virtual_function/"/>
    <url>/2020/07/07/cpp_virtual_function/</url>
    
    <content type="html"><![CDATA[<p>简单介绍了C++虚函数的基本概念和用法及其底层的实现原理</p><a id="more"></a><h1 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a>C++虚函数</h1><h2 id="基本概念与用法"><a href="#基本概念与用法" class="headerlink" title="基本概念与用法"></a>基本概念与用法</h2><p>虚函数是应在派生类中重新定义的成员函数。 当使用<strong>指针</strong>或对<strong>基类的引用</strong>来引用派生的类对象时，可以为该对象调用虚函数并执行该函数的派生类版本。虚函数是动态绑定的，所以<strong>不能</strong>将静态函数声明为虚函数。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span><span class="hljs-comment">//nonvirtual function</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in A::foo1"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span><span class="hljs-comment">//define a virtual function</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in A::foo2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span> <span class="hljs-keyword">public</span> A&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span><span class="hljs-comment">//nonvirtual function</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in B::foo1"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span>  <span class="hljs-comment">//virtual function</span></span><span class="hljs-function"><span class="hljs-comment">//virtual is optional explanation     </span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in B::foo2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A&amp; a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in func: "</span>;    a.foo2();<span class="hljs-comment">//call virtual function</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    A* b = <span class="hljs-keyword">new</span> B();    b-&gt;foo1();<span class="hljs-comment">//call nonvirtual function</span>    b-&gt;foo2();<span class="hljs-comment">//call virtual function</span>&#125;</code></pre><p>基类的虚函数必须定义，除非被声明为纯虚函数，即基类为抽象类。</p><p>基类当定义好后虚函数后，则在基类所有的派生类中，此函数都是虚函数，若没有被重载就会默认使用该派生类父类所重载的虚函数。</p><p>若要重载该虚函数，可以显式地使用<code>virtual</code>关键词（但不必要）来重载此虚函数。</p><p>派生类的虚函数的返回类型，参数列表需要同基类的虚函数相同，但也有例外情况，若基类返回的是类本身的指针或引用时，上述规则无效。</p><h3 id="final-与-override"><a href="#final-与-override" class="headerlink" title="final 与 override"></a>final 与 override</h3><p>C++11后，新增了两个后缀说明符<code>final</code>和<code>override</code>, <code>override</code>是可选的，用来显式说明该虚函数是被重载的，而<code>final</code>用来说明该类的虚函数不能被其派生类重载。</p><h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>若想指定地执行虚函数的某个版本，可以使用作用域运算符来实现，例如</p><pre><code class="hljs cpp">A* test = <span class="hljs-keyword">new</span> B();test-&gt;foo2();<span class="hljs-comment">//call B::foo2()</span>test-&gt;A::foo2(); <span class="hljs-comment">//call A::foo2()</span></code></pre><p>注：此调用是在编译时刻完成的。</p><h2 id="虚函数的实现"><a href="#虚函数的实现" class="headerlink" title="虚函数的实现"></a>虚函数的实现</h2><ol><li><p>每一个class产生出一堆指向virtual function 的指针，放在表格之中。这个表格被称为virtual table (<strong>vtbl</strong>)。</p></li><li><p>每一个class object 被安插了一个指针，指向相关的virtual table。通常这个指针被称为<strong>vptr</strong>。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/cover/cpp_virtual_function.jpg" srcset="/img/loading.gif" alt="未命名文件"></p></li></ol><p>在用派生类初始化基类的引用和指针时，编译器仅会修改指针的类型（即指针所指的内存的大小和其内容），但不会修改类中的<strong>vptr</strong>，所以类中的<strong>vptr</strong>指向的还是派生类的<strong>vtbl</strong>。注意指针所涵盖的地址只包含派生类中的派生于基类的成员，你不能通过其访问派生类特有的成员，但是你可以通过调用virtual function来访问派生类特有的成员。</p><p>在使用基类构造函数转化派生类时，会将<strong>vptr</strong>重新设定为基类的<strong>vptr</strong>，并不会沿用派生类的<strong>vptr</strong>，并对派生类的成员进行<strong>截断</strong>，只保留基类的成员，此时不会展现多态性。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-1 计算机系统漫游</title>
    <link href="/2020/07/06/CSAPP_1/"/>
    <url>/2020/07/06/CSAPP_1/</url>
    
    <content type="html"><![CDATA[<p>简单介绍了计算机系统的组成，存储层次结构，操作系统内核及其抽象的知识。</p><a id="more"></a><h2 id="1-计算机系统漫游"><a href="#1-计算机系统漫游" class="headerlink" title="1. 计算机系统漫游"></a>1. 计算机系统漫游</h2><h3 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/1.png" srcset="/img/loading.gif" alt="一个典型系统的硬件组成"></p><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>​        贯穿整个系统的是一组电子管道，成为<strong>总线</strong>，它携带信息字节并负责在各个部件间触底。通常总线被设计成传送定长的字节块，也就是<strong>字(word)</strong>。自重的字节是(即字长)是一个系统参数，各个系统都不尽相同。</p><h4 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h4><p>​        I/O(输入/输出)设备是系统与外部世界的联系通道。每个I/O设备都通过一个控制器或适配器与I/O总线连接。控制器和适配器的区别主要在它们的封装方式。控制器是I/O设备本身或者系统主印制电路板(通常称作<strong>主板</strong>)上的芯片组。而适配器则是一块插在主板插槽上的卡。</p><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>​        主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组<strong>动态随机存取存储器(DRAM)</strong>芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。</p><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>​        <strong>中央处理单元(CPU)</strong>，简称<strong>处理器</strong>，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或<strong>寄存器</strong>)，称为<strong>程序计数器(PC)</strong>。在任何时刻，PC都指向主存中的某条机器指令(即含有该条指令的地址)。</p><p>​        从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由<strong>指令集架构</strong>决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC， 使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</p><p>​        这样的简单操作并不多，它们围绕着主存、<strong>寄存器文件（register file)</strong>和<strong>算术/逻辑单元(ALU)</strong>进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。</p><ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原<br>来的内容。</li><li>操作：把两个寄存器的内容复制到ALU, ALU 对这两个字做算术运算，并将结果<br>存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC)中，以覆盖PC 中原来的值。</li></ul><p>​        处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/2.png" srcset="/img/loading.gif" alt="高速缓存存储器"></p><p>​        根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为<strong>高速缓存存储器(cache memory</strong>, 简称为<strong>cache</strong>或<strong>高速缓存</strong>)，作为暂时的集结区域，存放处理器近期可能会需要的信息。位于处理器芯片上的<strong>L1 高速缓存</strong>的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的<strong>L2 高速缓存</strong>通过一条特殊的总线连接到处理器。进程访问L2 高速缓存的时间要比访问L1 高速缓存的时间长5 倍，但是这仍然比访问主存的时间快5~10 倍。L1和L2 高速缓存是用一种叫做<strong>静态随机访问存储器(SRAM)</strong>的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2 和L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p><h3 id="存储设备层次结构"><a href="#存储设备层次结构" class="headerlink" title="存储设备层次结构"></a>存储设备层次结构</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/3.png" srcset="/img/loading.gif" alt="一个存储器层次结构的示例"></p><h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/4.png" srcset="/img/loading.gif" alt="计算机系统的分层视图"></p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/5.png" srcset="/img/loading.gif" alt="操作系统提供的抽象表示"></p><p>​        操作系统有两个基本功能：</p><p>​        1. 防止硬件被失控的应用程序滥用；</p><p>​        2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</p><p>​        操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I/O 设备的抽象表示，虚拟内存是对主存和磁盘I/O 设备的抽象表示，进程则是对处理器、主存和I/O 设备的抽象表示。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​        <strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU 个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</p><p>​        操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，包括许多信息，比如PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/6.png" srcset="/img/loading.gif" alt="进程的上下文切换"></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>​        尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>​        <strong>虚拟内存</strong>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/7.png" srcset="/img/loading.gif" alt="进程的虚拟地址空间"></p><p>​        每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p><ul><li><p><strong>程序代码和数据</strong>。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</p></li><li><p><strong>堆</strong>。代码和数据区后紧随着的是运行时<strong>堆</strong>。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C 标准库函数时，堆可以在运行时动态地扩展和收缩。</p></li><li><p><strong>共享库</strong>。大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</p></li><li><p><strong>栈</strong>。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</p></li><li><p><strong>内核虚拟内存</strong>。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</p></li></ul><p>​        虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>​        文件就是字节序列，仅此而已。每个I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输人输出都是通过使用一小组称为Unix I/O 的系统函数调用读写文件来实现的。</p><h3 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/8.png" srcset="/img/loading.gif" alt="网络也是一种I/O设备"></p><p>​        现代操作系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个I/O 设备，如图所示。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p><p>​        随着Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为<br>计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP和telnet 这样的应用都是基于网络复制信息的功能。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/9.png" srcset="/img/loading.gif" alt="利用telnet通过网络远程运行hello"></p><h3 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h3><p>​        该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为$T_{old}$。假设系统某部分所需执行时间与该时间的比例为 $\alpha$，而该部分性能提升比例为 $k$。即该部分初始所需时间为 $\alpha T_{old}$ ，现在所需时间为$\alpha T_{old}/k$。因此，总的执行时间应为<br>$$<br>T_{new} = (1-\alpha)T_{old} + (\alpha T_{old})/k = T_{old} [(1-\alpha)+\alpha/k]<br>$$<br>由此，可以计算加速比$S =T_{new}/T_{old} $为<br>$$<br>S = \frac{1}{(1-\alpha)+\alpha/k}<br>$$<br>考虑 $k$ 趋向于$\infty$时</p><p>$$<br>S_\infty = \frac{1}{1-\alpha}<br>$$</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>​        我们用的术语<strong>并发(concurrency)</strong>是一个通用的概念，指一个同时具有多个活动的系统；而术语<strong>并行（parallelism)</strong>指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。</p><h4 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h4><p>​        构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。传统意义上，这种并发执行只是<strong>模拟</strong>出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为<strong>单处理器系统</strong>。</p><p>​        当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个<strong>多处理器系统</strong>。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/10.png" srcset="/img/loading.gif" alt="不同处理器配置分类"></p><p>多核处理器是将多个CPU(称为“核”)集成到一个集成电路芯片上</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/11.png" srcset="/img/loading.gif" alt="多核处理器的组织结构"></p><p>​        <strong>超线程</strong>，有时称为<strong>同时多线程(simultaneous multi-threading)</strong>, 是一项允许一个CPU执行多个控制流的技术。它涉及CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约20 000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU 能够更好地利用它的处理资源。</p><p>​        多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过50年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。</p><h4 id="指令级并发"><a href="#指令级并发" class="headerlink" title="指令级并发"></a>指令级并发</h4><p>​        在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。在<strong>流水线(pipelining)</strong>中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。</p><h4 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h4><p>​        在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为<strong>单指令、多数据</strong>，即<strong>SIMD 并行</strong>。例如，较新几代的Intel 和AMD处理器都具有并行地对8 对单精度浮点数(C 数据类型float)做加法的指令。</p><p>​        提供这些SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C 程序中自动抽取SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC 就支持向量数据类型。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/12.png" srcset="/img/loading.gif" alt="虚拟机"></p><p>​        <strong>虚拟机</strong>，它提供对整个计算机的抽象，包括操作系统、处理器和程序。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
