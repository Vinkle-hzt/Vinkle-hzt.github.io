<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ Template-3 非类型模板参数</title>
    <link href="/2020/07/22/cpp-template-3/"/>
    <url>/2020/07/22/cpp-template-3/</url>
    
    <content type="html"><![CDATA[<p>通过大量例子介绍了非类型模板参数。你可以学习到如何使用非类型模板参数，了解非类型模板参数使用的限制。</p><a id="more"></a><p>这<strong>不是</strong>本系列第一篇文章，推荐阅读完前面的文章再看本文，以下是本系列文章目录。</p><p><a href="https://vinkle.top/2020/07/09/cpp-template-1/#1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">1. 函数模板</a></p><p><a href="https://vinkle.top/2020/07/17/cpp-template-2/#2-%E7%B1%BB%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">2. 类模板</a></p><p><a href="#3-非类型模板参数">3. 非类型模板参数（本文）</a></p><h1 id="3-非类型模板参数"><a href="#3-非类型模板参数" class="headerlink" title="3. 非类型模板参数"></a>3. 非类型模板参数</h1><p>对于函数模板和类模板，模板参数不一定必须为类型，它们也可以是普通的值。和使用类型作为模板参数类似，你可以使代码的部分细节留到使用的时候再确定。只是，这些待定的细节不再是类型，而是某个数值。当我们使用这种模板的时候，你必须显式地表明出数值的具体值，之后代码才会被实例化。本章会通过一个新版本的 stack 类模板来说明这一新特性。顺便我们会介绍一下函数模板的非类型参数的使用，并讨论这一技术的一些局限性。</p><h2 id="3-1-类模板的非类型参数"><a href="#3-1-类模板的非类型参数" class="headerlink" title="3.1 类模板的非类型参数"></a>3.1 类模板的非类型参数</h2><p>作为和前面章节实现的 stack 的对比，你可以实现一个用一个固定大小的数组作为容器的 stack。这种方式的优点是可以避免开发者或者标准库容器管理内存的开销。不同，确定一个合适的大小是一个难题。如果指定的值太小，那么 stack 容器就容易满。如果指定的大小太大，可能造成内存的浪费。因此最好让用户根据自身的情况合理确定 stack 的大小</p><p>为此，可以将 stack 的大小定义成模板参数：</p><pre><code class="hljs c++"><span class="hljs-comment">//stacknontype.hpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Maxsize&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;T, Maxsize&gt; elems; <span class="hljs-comment">// elements</span>    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> numElems;         <span class="hljs-comment">// current number of elements</span><span class="hljs-keyword">public</span>:    Stack();                  <span class="hljs-comment">// constructor</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; elem)</span></span>; <span class="hljs-comment">// push element</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// pop element</span>    <span class="hljs-function">T <span class="hljs-keyword">const</span>&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;     <span class="hljs-comment">// return top element</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// return whether the stack is empty</span>        <span class="hljs-keyword">return</span> numElems == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// return current number of elements</span>        <span class="hljs-keyword">return</span> numElems;    &#125;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Maxsize&gt;Stack&lt;T, Maxsize&gt;::Stack()    : numElems(<span class="hljs-number">0</span>) <span class="hljs-comment">// start with no elements</span>&#123;    <span class="hljs-comment">// nothing else to do</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Maxsize&gt;<span class="hljs-keyword">void</span> Stack&lt;T, Maxsize&gt;::push(T <span class="hljs-keyword">const</span>&amp; elem)&#123;    assert(numElems &lt; Maxsize);    elems[numElems] = elem; <span class="hljs-comment">// append element</span>    ++numElems;             <span class="hljs-comment">// increment number of elements</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Maxsize&gt;<span class="hljs-keyword">void</span> Stack&lt;T, Maxsize&gt;::pop()&#123;    assert(!elems.empty());    --numElems; <span class="hljs-comment">// decrement number of elements</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Maxsize&gt;T <span class="hljs-keyword">const</span> &amp;Stack&lt;T, Maxsize&gt;::top() <span class="hljs-keyword">const</span>&#123;    assert(!elems.empty());    <span class="hljs-keyword">return</span> elems[numElems - <span class="hljs-number">1</span>]; <span class="hljs-comment">// return last element</span>&#125;</code></pre><p>第二个新的模板参数 <code>Maxsize</code> 是 <code>int</code> 类型的，它指定了 stack 中数组中的大小：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Maxsize&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;T, Maxsize&gt; elems; <span class="hljs-comment">// elements</span>    ...&#125;;</code></pre><p>另外，成员函数 <code>push()</code> 在使用时也检测了 stack 是否已满：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Maxsize&gt;<span class="hljs-keyword">void</span> Stack&lt;T, Maxsize&gt;::push(T <span class="hljs-keyword">const</span>&amp; elem)&#123;    assert(numElems &lt; Maxsize);    elems[numElems] = elem; <span class="hljs-comment">// append element</span>    ++numElems;             <span class="hljs-comment">// increment number of elements</span>&#125;</code></pre><p>为了使用这个类模板你必须同时显式地写出 stack 中元素的类型和其最大容量：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stacknontype.hpp"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  Stack&lt;<span class="hljs-keyword">int</span>,<span class="hljs-number">20</span>&gt;         int20Stack;     <span class="hljs-comment">// stack of up to 20 ints</span>  Stack&lt;<span class="hljs-keyword">int</span>,<span class="hljs-number">40</span>&gt;         int40Stack;     <span class="hljs-comment">// stack of up to 40 ints</span>  Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>,<span class="hljs-number">40</span>&gt; stringStack;    <span class="hljs-comment">// stack of up to 40 strings</span>  <span class="hljs-comment">// manipulate stack of up to 20 ints</span>  int20Stack.push(<span class="hljs-number">7</span>);  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; int20Stack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;  int20Stack.pop();  <span class="hljs-comment">// manipulate stack of up to 40 strings</span>  stringStack.push(<span class="hljs-string">"hello"</span>);  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; stringStack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;  stringStack.pop();&#125;</code></pre><p>注意，上面每一个模板都实例化出一个不同的类型。因此，<code>int20Stack</code> 和 <code>int40Stack</code> 它们的类型是不同的，而且它们之间没有定义隐式或者是显式的类型转换规则。因此，不能用其中一个取代另一个，也不能将其中一个赋值给另外一个。</p><p>同时，对于非类型模板参数来说，也可以指定默认值：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Maxsize = <span class="hljs-number">100</span>&gt;class Stack&#123;    ...&#125;;</code></pre><p>但是，从良好的程序设计的角度来看，这可能不是一个合适的例子。默认值应该直观地看上去是正确的。不过对于默认类型是 <code>int</code> 或者是默认大小是 <code>100</code> 对于一般的 stack 模板看上去都不够直观。因此，最好是让程序员同时显式地指定这两个模板参数，这样在声明的时候这个两个模板参数都可以被<strong>文档化(documented)</strong>。</p><h2 id="3-2-非类型函数模板参数"><a href="#3-2-非类型函数模板参数" class="headerlink" title="3.2 非类型函数模板参数"></a>3.2 非类型函数模板参数</h2><p>你也可以为函数模板定义非类型模板参数。例如，下面这个函数模板定义了一组可以添加一个确定的值的函数：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">int</span> Val, <span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">addValue</span><span class="hljs-params">(T x)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> x + Val;&#125;</code></pre><p>这类函数或者操作作用于其他函数的参数时，会十分有用。例如，当你使用 C++ 标准库时，你可以传递实例化后的次函数模板来为每一个元素添加一个值：</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::transform(source.<span class="hljs-built_in">begin</span>(), source.<span class="hljs-built_in">end</span>(), <span class="hljs-comment">// start and end of source</span>               dest.<span class="hljs-built_in">begin</span>(),                 <span class="hljs-comment">// start of destination</span>               addValue&lt;<span class="hljs-number">5</span>,<span class="hljs-keyword">int</span>&gt;);             <span class="hljs-comment">// operation</span></code></pre><p>最后一个参数是 <code>addValue&lt;&gt;()</code> 实例化出可以传入 <code>int</code> 类型的值，并为其加 <code>5</code> 的函数实例。这个函数会用来处理 <code>source</code> 中的每一个元素，必将结果保存在 <code>dest</code> 中。</p><p>注意在这一你必须显式指出 <code>addValue&lt;&gt;()</code> 的模板参数 <code>T</code> 的类型是 <code>int</code>。因为模板参数类型推导只会在立即发生的调用中起作用，但是 <code>std::transform()</code> 需要一个完整的类型去推导第四个模板参数。目前还不支持部分替换或推导模板参数然后再根据情况推导出剩余的模板参数。</p><p>同样，你也可以指出模板参数是从前一个参数推导出来的。比如，通过传入的非类型模板参数来推导出返回类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">auto</span> Val, <span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">decltype</span>(Val)&gt;T foo();</code></pre><p>或者可以通过以下方式确保非类型模板参数的类型和返回类型一样：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, T Val = T&#123;&#125;&gt;T bar();</code></pre><h2 id="3-3-非类型模板参数的限制"><a href="#3-3-非类型模板参数的限制" class="headerlink" title="3.3 非类型模板参数的限制"></a>3.3 非类型模板参数的限制</h2><p>注意非类型模板参数会带来某些限制。通常，他们只可以是整型的常量（包括枚举），指向 objects/functions/members 的指针，objects/functions 的左值引用，或者 <code>std::nullptr_t</code>（<code>nullptr</code> 的类型）。</p><p>浮点型数值或者 class 类型的对象是不允许作为非类型模板参数的：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">double</span> VAT&gt;      <span class="hljs-comment">// ERROR: floating-point values are not</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">process</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> v)</span> <span class="hljs-comment">// allowed as template parameters</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> v * VAT;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name&gt; <span class="hljs-comment">// ERROR: class-type objects are not</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>               // <span class="hljs-title">allowed</span> <span class="hljs-title">as</span> <span class="hljs-title">template</span> <span class="hljs-title">parameters</span></span><span class="hljs-class">&#123;</span>     ...&#125;;</code></pre><p>当传递指针或者引用给模板参数时，这个对象不能为字符串常量，临时变量或者数据成员以及其他子对象。在 C++17 之前，每个 C++ 版本的更新都会放宽这个限制：</p><ul><li>在 C++11 中，对象必须要有外部链接。</li><li>在 C++14 中，对象必须要有外部链接或者内部链接。</li></ul><p>因此下面的写法是不正确的：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>* name&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span><span class="hljs-class">&#123;</span>    ...&#125;;MyClass&lt;<span class="hljs-string">"hello"</span>&gt; x; <span class="hljs-comment">// ERROR: class-type objects are not</span>                    <span class="hljs-comment">//        allowed as template parameters</span></code></pre><p>但是有如下的变通方法（视 C++ 版本而定）：</p><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> s03[] = <span class="hljs-string">"hi"</span>;  <span class="hljs-comment">// external linkage</span><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> s11[] = <span class="hljs-string">"hi"</span>;         <span class="hljs-comment">// internal linkage</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Message&lt;s03&gt; m03;            <span class="hljs-comment">// OK(all versions)</span>    Message&lt;s11&gt; m11;            <span class="hljs-comment">// OK since C++11</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> s17[] = <span class="hljs-string">"hi"</span>; <span class="hljs-comment">// no linkage</span>    Message&lt;s17&gt; m17;               <span class="hljs-comment">// OK since C++17</span>&#125;</code></pre><p>在上面三种情况中字符数组都是被 <code>&quot;hi&quot;</code> 初始化，这个对象被用来作为被声明为 <code>char const*</code> 的模板参数。如果这个对象有外部链接（<code>s03</code>），那么在所有版本都是有效的，如果对象有内部链接，那么对 C++11 和 C++14 也是有效的，从 C++17开始，即使对象没有链接属性也是有效的。</p><p><a href>12.3.3 节（未写)</a>对这一问题进行了更加详细的讨论，<a href>17.2 节（未写）</a>对这一问题未来的变化进行了讨论。</p><h3 id="避免无效的表达式"><a href="#避免无效的表达式" class="headerlink" title="避免无效的表达式"></a>避免无效的表达式</h3><p>非类型模板参数可以使任何编译期的表达式，比如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">bool</span> B&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>;</span>...C&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) + <span class="hljs-number">4</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) == <span class="hljs-number">4</span>&gt; c;</code></pre><p>不过如果在表达式中使用了 <code>operator &gt;</code>，就必须将相应的表达式放在括号里面，否则 <code>&gt;</code> 会被认为模板参数列表末尾的 <code>&gt;</code>:</p><pre><code class="hljs c++">C&lt;<span class="hljs-number">42</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &gt; <span class="hljs-number">4</span>&gt; c; <span class="hljs-comment">// ERROR: first &gt; ends the template argument list</span>C&lt;<span class="hljs-number">42</span>, (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &gt; <span class="hljs-number">4</span>)&gt; c; <span class="hljs-comment">// OK</span></code></pre><h2 id="3-4-模板参数类型-auto"><a href="#3-4-模板参数类型-auto" class="headerlink" title="3.4 模板参数类型 auto"></a>3.4 模板参数类型 auto</h2><p>从 C++17 开始，你可以定义非类型模板参数来接受任何允许的非类型模板参数。通过这一特性，我们可以设计一个更加泛化的有固定大小的 stack：</p><pre><code class="hljs c++"><span class="hljs-comment">//stackauto.hpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> Maxsize&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">decltype</span>(Maxsize);<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;T, Maxsize&gt; elems; <span class="hljs-comment">// elements</span>    size_type numElems;           <span class="hljs-comment">// current number of elements</span><span class="hljs-keyword">public</span>:    Stack();                  <span class="hljs-comment">// constructor</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; elem)</span></span>; <span class="hljs-comment">// push element</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// pop element</span>    <span class="hljs-function">T <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;     <span class="hljs-comment">// return top element</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>        <span class="hljs-comment">// return whether the stack is empty</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">return</span> numElems == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>    <span class="hljs-comment">// return current number of elements</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">return</span> numElems;    &#125;&#125;;<span class="hljs-comment">// constructor</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> Maxsize&gt;Stack&lt;T, Maxsize&gt;::Stack()    : numElems(<span class="hljs-number">0</span>) <span class="hljs-comment">// start with no elements</span>&#123;    <span class="hljs-comment">// nothing else to do</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> Maxsize&gt;<span class="hljs-keyword">void</span> Stack&lt;T, Maxsize&gt;::push(T <span class="hljs-keyword">const</span>&amp; elem)&#123;    assert(numElems &lt; Maxsize);    elems[numElems] = elem; <span class="hljs-comment">// append element</span>    ++numElems;             <span class="hljs-comment">// increment number of elements</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> Maxsize&gt;<span class="hljs-keyword">void</span> Stack&lt;T, Maxsize&gt;::pop()&#123;    assert(!elems.empty());    --numElems; <span class="hljs-comment">// decrement number of elements</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> Maxsize&gt;T <span class="hljs-keyword">const</span> &amp;Stack&lt;T, Maxsize&gt;::top() <span class="hljs-keyword">const</span>&#123;    assert(!elems.empty());    <span class="hljs-keyword">return</span> elems[numElems - <span class="hljs-number">1</span>]; <span class="hljs-comment">// return last element</span>&#125;</code></pre><p>通过定义</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> Maxsize&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span>    ...&#125;;</code></pre><p>通过使用 <em>placeholder type</em> <code>auto</code>，你定义了类型待定的 <code>Maxsize</code>。它的类型可以使任何费类型模板参数所允许的类型。</p><p>在模板内存，你可以直接使用它的值：</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;T, Maxsize&gt; elems; <span class="hljs-comment">// elements</span></code></pre><p>也可以使用它的类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">decltype</span>(Maxsize);</code></pre><p>然后也可以作为 <code>size()</code> 函数的返回类型：</p><pre><code class="hljs c++"><span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>    <span class="hljs-comment">// return current number of elements</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> numElems;&#125;</code></pre><p>从 C++ 14 开始，你也可以只使用 <code>auto</code> 作为返回值，让编译器推导出返回的类型：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>        <span class="hljs-comment">// return current number of elements</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> numElems;&#125;</code></pre><p>根据类的声明，<code>numElems</code> 的类型是由非类型模板参数的类型来决定的：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stackauto.hpp"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  Stack&lt;<span class="hljs-keyword">int</span>,<span class="hljs-number">20u</span>&gt;        int20Stack;     <span class="hljs-comment">// stack of up to 20 ints</span>  Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>,<span class="hljs-number">40</span>&gt; stringStack;    <span class="hljs-comment">// stack of up to 40 strings</span>  <span class="hljs-comment">// manipulate stack of up to 20 ints</span>  int20Stack.push(<span class="hljs-number">7</span>);  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; int20Stack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;  <span class="hljs-keyword">auto</span> size1 = int20Stack.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// manipulate stack of up to 40 strings</span>  stringStack.push(<span class="hljs-string">"hello"</span>);  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; stringStack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;  <span class="hljs-keyword">auto</span> size2 = stringStack.<span class="hljs-built_in">size</span>();  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">decltype</span>(size1), <span class="hljs-keyword">decltype</span>(size2)&gt;)     <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"size types differ"</span> &lt;&lt; <span class="hljs-string">'\n'</span>;&#125;</code></pre><p>对于</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-keyword">int</span>,<span class="hljs-number">20u</span>&gt; int20Stack;     <span class="hljs-comment">// stack of up to 20 ints</span></code></pre><p>由于传递的非类型模板参数是 <code>20u</code>，因此 <code>size_type</code> 的类型是 <code>unsigned int</code>。</p><p>对于</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>,<span class="hljs-number">40</span>&gt; stringStack; <span class="hljs-comment">// stack of up to 40 strings</span></code></pre><p>因为传递的非类型模板参数是 <code>40</code>， 因此 <code>size_type</code> 的类型是 <code>int</code>。</p><p>两种 stack 的 <code>size()</code> 函数的返回类型是不同的，所以</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> size1 = int20Stack.<span class="hljs-built_in">size</span>();...<span class="hljs-keyword">auto</span> size2 = stringStack.<span class="hljs-built_in">size</span>();</code></pre><p>中的 <code>size1</code> 和 <code>size2</code> 的类型也是不同的。通过使用 <em>standard type trait</em> <code>std::is_same</code> 和 <code>decltype</code>，可以验证：</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">std</span>::is_same&lt;<span class="hljs-keyword">decltype</span>(size1), <span class="hljs-keyword">decltype</span>(size2)&gt;::value)     <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"size types differ"</span> &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre><p>输出的结果是：</p><pre><code class="hljs arduino"><span class="hljs-built_in">size</span> types differ</code></pre><p>从 C++17 开始，对于返回类型的 <em>type trait</em>，可以通过后缀 <code>_v</code> 来省略 <code>::value</code> （<a href>参考5.6节 （未写）</a>）：</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">decltype</span>(size1), <span class="hljs-keyword">decltype</span>(size2)&gt;)     <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"size types differ"</span> &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre><p>注意非类型模板的限制依然存在。尤其是那些 <a href="#3-3-非类型模板参数的限制">3.3 节</a>讨论的限制。比如：</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">3.14</span>&gt; sd; <span class="hljs-comment">// ERROR: Floating-point nontype argument</span></code></pre><p>由于你可以传递字符串常量数组作为非类型模板参数（从 C++17 开始甚至可以是静态的局部变量，<a href="#3-3-非类型模板参数的限制">参见 3.3 节</a>），下面的用法也是正确的：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> T&gt;       <span class="hljs-comment">// take value of any possible nontype parameter (since C++17)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span><span class="hljs-function">    </span>&#123;      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; T &lt;&lt; <span class="hljs-string">'\n'</span>;     &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  Message&lt;<span class="hljs-number">42</span>&gt; msg1;  msg1.<span class="hljs-built_in">print</span>();        <span class="hljs-comment">// initialize with int 42 and print that value</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> s[] = <span class="hljs-string">"hello"</span>;  Message&lt;s&gt; msg2;     <span class="hljs-comment">// initialize with char~const[6] "hello"</span>  msg2.<span class="hljs-built_in">print</span>();        <span class="hljs-comment">// and print that value</span>&#125;</code></pre><p>也可以使用 <code>template &lt;decltype(auto) N&gt;</code>，这样可以将 <code>N</code> 实例化为引用类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) N&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span><span class="hljs-class">&#123;</span>    ...&#125;;<span class="hljs-keyword">int</span> i;C&lt;(i)&gt; x; <span class="hljs-comment">// N is int&amp;</span></code></pre><p>更多细节<a href>参见 15.10.1 节（未写）</a>。</p><h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><ul><li>模板参数不只可以是类型，也可以是值。</li><li>你不可以将浮点类型和 class 类型对象作为非类型模板参数。使用字符串常量，临时变量，子对象的指针和引用也会有一些限制。</li><li>通过使用关键字 <code>auto</code>，可以使非类型模板参数的类型更加泛化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Template</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Template-2 类模板</title>
    <link href="/2020/07/17/cpp-template-2/"/>
    <url>/2020/07/17/cpp-template-2/</url>
    
    <content type="html"><![CDATA[<p>运用大量例子介绍了类模板。你可以学习到如何声明和定义类模板，如何使用类模板，如何特化和偏特化类模板，类模板的参数推导等相关的知识。</p><a id="more"></a><p>这<strong>不是</strong>本系列第一篇文章，推荐阅读完前面的文章再看本文，以下是本系列文章目录。</p><p><a href="https://vinkle.top/2020/07/09/cpp-template-1/#1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">1. 函数模板</a></p><p><a href="#2-类模板">2. 类模板 （本文）</a></p><p><a href>3. 非类型模板参数（正在编写）</a></p><h1 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2. 类模板"></a>2. 类模板</h1><p>跟函数类似，类也可以被实例化成一个或者多个类型。这个特性的典型例子就是可以用于管理特性类型元素的<strong>容器类(container classes)</strong>。通过使用类模板，你可以实现适用于多个模板的容器类，在本章中，我们将以<strong>栈(stack)</strong>为示例介绍类模板的使用。</p><h2 id="2-1-Stack-类模板的实现"><a href="#2-1-Stack-类模板的实现" class="headerlink" title="2.1. Stack 类模板的实现"></a>2.1. Stack 类模板的实现</h2><p>我们可以像函数模板一样声明和定义 <code>Stack&lt;&gt;</code></p><pre><code class="hljs c++"><span class="hljs-comment">//stack1.hpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; elems;     <span class="hljs-comment">// elements</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; elem)</span></span>; <span class="hljs-comment">// push element</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// pop element</span>    <span class="hljs-function">T <span class="hljs-keyword">const</span>&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;     <span class="hljs-comment">// return top element</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123;                         <span class="hljs-comment">// return whether the stack is empty</span>        <span class="hljs-keyword">return</span> elems.empty();    &#125;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">void</span> Stack&lt;T&gt;::push(T <span class="hljs-keyword">const</span>&amp; elem)&#123;    elems.push_back(elem);    <span class="hljs-comment">// append copy of passed elem</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">void</span> Stack&lt;T&gt;::pop()&#123;    assert(!elems.empty());    elems.pop_back();         <span class="hljs-comment">// remove last element</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;T <span class="hljs-keyword">const</span>&amp; Stack&lt;T&gt;::top() <span class="hljs-keyword">const</span>&#123;    assert(!elems.empty());    <span class="hljs-keyword">return</span> elems.back();      <span class="hljs-comment">// return copy of last element</span>&#125;</code></pre><p>如你所见，这个类模板是通过 C++ 标准库中的 <code>vector&lt;&gt;</code> 来实现的。这样我们就不必自己实现内存管理，拷贝构造和拷贝赋值运算符了，从而可以专注于这个类模板的接口实现上面。</p><h3 id="2-1-1-声明类模板"><a href="#2-1-1-声明类模板" class="headerlink" title="2.1.1 声明类模板"></a>2.1.1 声明类模板</h3><p>声明类模板和声明函数模板类似：正在定义之前，你必须先声明一个或多个作为模板类型参数的标志符。同样，这个标志符通常用 <code>T</code> 表示</p><p><em>template &lt;typename T&gt;</em></p><p><em>class Stack{</em></p><p><em>…</em></p><p><em>};</em></p><p>在这里同样可以用 <code>class</code> 取代 <code>typename</code> （但不推荐）</p><p><em>template &lt;class T&gt;</em></p><p><em>class Stack{</em></p><p><em>…</em></p><p><em>};</em></p><p>在类模板内部，<code>T</code> 可以像普通类型一样被用来声明成员变量和成员函数。在这个例子中，<code>T</code> 被用来声明 <code>vector</code>中元素的类型，用于声明成员函数 <code>push()</code> 的参数类型，也用于声明了成员函数 <code>top()</code> 的返回类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; elems;     <span class="hljs-comment">// elements</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; elem)</span></span>; <span class="hljs-comment">// push element</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// pop element</span>    <span class="hljs-function">T <span class="hljs-keyword">const</span>&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;     <span class="hljs-comment">// return top element</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123;                         <span class="hljs-comment">// return whether the stack is empty</span>        <span class="hljs-keyword">return</span> elems.empty();    &#125;&#125;;</code></pre><p>这个类的类型是 <code>Stack&lt;T&gt;</code>， 其中 <code>T</code> 是模板参数。因此，你必须在你声明 <code>Stack&lt;T&gt;</code> 时，除非可以推断出模板参数的类型，否则必须使用 <code>Stack&lt;T&gt;</code>。不过，在类模板中使用不带模板参数的类型名的类（如 <code>Stack</code>），说明了这个成员类的模板参数和类模板的模板参数类型相同。</p><p>如果你需要定义自己的拷贝构造和拷贝复制运算符，通常应该定义成这样子：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span>    ...    Stack(Stack <span class="hljs-keyword">const</span>&amp;);              <span class="hljs-comment">//copy constructor</span>    Stack&amp; <span class="hljs-keyword">operator</span>=(Stack <span class="hljs-keyword">const</span>&amp;);<span class="hljs-comment">//assignment operator</span>    ...&#125;;</code></pre><p>它和下面的定义时等价的：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span>    ...    Stack(Stack&lt;T&gt; <span class="hljs-keyword">const</span>&amp;); <span class="hljs-comment">//copy constructor</span>    Stack&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(Stack&lt;T&gt; <span class="hljs-keyword">const</span>&amp;);<span class="hljs-comment">//assignment operator</span>    ...&#125;;</code></pre><p>但是一般 <code>&lt;T&gt;</code> 暗示要对一些特殊的模板参数做一些特定处理，所以最好还是使用第一种方式。</p><p>但是，如果在类模板外，就需要这样定义：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">bool</span> Stack&lt;T&gt;::<span class="hljs-keyword">operator</span>==(Stack&lt;T&gt; <span class="hljs-keyword">const</span>&amp; lhs, Stack&lt;T&gt; <span class="hljs-keyword">const</span>&amp; rhs);</code></pre><p>注意在 <code>Stack</code> 只适用于仅需要类名称而不是类类型的地方。这和声明构造函数和析构函数的情况相同。</p><p>同样注意，不像非模板类，你不可以在函数内部或者块作用域内声明和定义类模板。总之，模板只能定义在 global/namespace 作用域中（细节后续再讲）。</p><h3 id="2-1-2-成员函数的实现"><a href="#2-1-2-成员函数的实现" class="headerlink" title="2.1.2 成员函数的实现"></a>2.1.2 成员函数的实现</h3><p>定义类模板的成员函数时，你必须显示指出他是一个模板，而且你必须使用类模板的所有类型限制。因此，要像下面这样定义 <code>Stack&lt;T&gt;</code> 中的成员函数 <code>push()</code>:</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">void</span> Stack&lt;T&gt;::push(T <span class="hljs-keyword">const</span>&amp; elem)&#123;    elems.push_back(elem);    <span class="hljs-comment">// append copy of passed elem</span>&#125;</code></pre><p>这里调用了<code>vector</code> 类型成员 <code>push_back()</code> 方法，它用于在 <code>vector</code> 尾部追加一个元素。</p><p>注意 <code>vector</code> 的 <code>pop_back()</code> 方法只是删除掉尾部的元素，并不会返回这一元素。这主要是为了<strong>异常安全(exception safety)</strong>。实现一个异常安全并且能够返回被删除元素的 <code>pop()</code> 方法是不可能的。不过如果忽略掉这一风险，我们依然可以实现一个返回被删除元素的 <code>pop()</code>。为了达到这一目的，我们只需要用 <code>T</code> 定义一个和 <code>vector</code> 元素有相同类型的局部变量就可以了：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;T Stack&lt;T&gt;::pop ()&#123;    assert(!elems.empty());    T elem = elems.back();  <span class="hljs-comment">// save copy of last element</span>    elems.pop_back(); <span class="hljs-comment">// remove last element</span>    <span class="hljs-keyword">return</span> elem; <span class="hljs-comment">// return copy of saved element</span>&#125;</code></pre><p>由于 <code>vector</code> 的 <code>back()</code>（ 返回其最后一个元素）和 <code>pop_back()</code>（ 删除最后一个元素）方法在 <code>vector</code> 为空的时候行为未定义，因此需要对 <code>vector</code> 是否为空进行测试。在程序中我们<strong>断言(assert)</strong> <code>vector</code> 不能为空，这样可以确保不会对空的 <code>Stack</code> 调用 <code>pop()</code> 方法。在 <code>top()</code> （返回但是不删除首元素）中也是如此：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;T <span class="hljs-keyword">const</span>&amp; Stack&lt;T&gt;::top() <span class="hljs-keyword">const</span>&#123;    assert(!elems.empty());    <span class="hljs-keyword">return</span> elems.back();      <span class="hljs-comment">// return copy of last element</span>&#125;</code></pre><p>当然，如同其他成员函数一样，你也可以把类模板的成员函数以内联函数的形式实现在类模板的内部，比如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span>    ...    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; elem)</span></span><span class="hljs-function">    </span>&#123;        elems.push_back(elem);    <span class="hljs-comment">// append copy of passed elem</span>    &#125;    ...&#125;</code></pre><h2 id="2-2-Stack-类模板的使用"><a href="#2-2-Stack-类模板的使用" class="headerlink" title="2.2. Stack 类模板的使用"></a>2.2. Stack 类模板的使用</h2><p>在 C++17 之前，在使用类模板的时候都需要显式地指明模板参数，下面的例子展示了该如何使用 <code>Stack&lt;&gt;</code> 类模板：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stack1.hpp"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  Stack&lt;<span class="hljs-keyword">int</span>&gt;         intStack;       <span class="hljs-comment">// stack of ints</span>  Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; stringStack;    <span class="hljs-comment">// stack of strings</span>  <span class="hljs-comment">// manipulate int stack</span>  intStack.push(<span class="hljs-number">7</span>);  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; intStack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;  <span class="hljs-comment">// manipulate string stack</span>  stringStack.push(<span class="hljs-string">"hello"</span>);  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; stringStack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;  stringStack.pop();&#125;</code></pre><p>通过声明 <code>Stack&lt;int&gt;</code> 类型，在类模板内部 <code>int</code> 会被用作类型 <code>T</code>。因此，被创建的对象 <code>intStack</code>会使用一个存储<code>int</code> 类型的 <code>vector</code>，所用调用的成员函数都会被用 <code>int</code> 实例化。同样的，对于用 <code>Stack&lt;std::string&gt;</code> 定义的对象，它会使用一个存储 <code>std::string</code> 的 <code>vector</code>，所有调用的成员函数也会被 <code>std::string</code> 实例化。</p><p><strong>注意，模板（成员）函数只有在调用时才会被实例化。</strong>对于类模板来说，成员函数只有被调用时才会实例化。这样节省了时间和空间的消耗，也允许了对类模板进行局部使用，<a href="#2-3-类模板的局部使用">在 2.3 节会讨论到</a>。</p><p>在这个例子中，默认构造函数，<code>push()</code> 和 <code>top()</code> 被实例化为 <code>int</code> 和 <code>std::string</code>。但是， <code>pop()</code> 仅被实例化为 <code>std::string</code>。如果类模板有静态成员，对于每一个用到类模板的类型，相应的静态成员也只会被实例化一次。</p><p>被实例化的类模板类型可以向常规类型一样使用。你可以使用 <code>const</code> 或者 <code>volatile</code> 来修饰它，也可以创建相应的数组和引用。你可以通过 <code>typedef</code> 和 <code>using</code> 将他作为类型定义的一部分（<a href="#2-8-类型别名">2.8 节会讨论到</a>）或者可以用它来实例化其他的模板类型，比如：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Stack&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">const</span>&amp; s)</span>  <span class="hljs-comment">// 参数 s 类型是 Stack&lt;int&gt;</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> IntStack = Stack&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">//IntStack 是 Stack&lt;int&gt; 的别名</span>    Stack&lt;<span class="hljs-keyword">int</span>&gt; istack[<span class="hljs-number">10</span>]; <span class="hljs-comment">//istack 是大小为 10 的 Stack&lt;int&gt; 类型数组</span>    IntStack istack2[<span class="hljs-number">10</span>];    <span class="hljs-comment">//istack2 同样是大小为 10 的 Stack&lt;int&gt; 类型数组</span>&#125;</code></pre><p>模板参数可以使任意类型，比如指向 <code>float</code> 的指针，甚至是存储 <code>int</code> 的 <code>stack</code>：</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-keyword">float</span>*&gt;     floatPtrStack; <span class="hljs-comment">// 存储 float 的 stack</span>Stack&lt;Stack&lt;<span class="hljs-keyword">int</span>&gt;&gt; intStackStack; <span class="hljs-comment">// 存储存储 int 的 stack 的 stack</span></code></pre><p>模板参数唯一要求是：他要支持模板中此类型所有相关的操作。</p><p>在 C++11 之前，在两个相邻的模板尖括号之前必须要有空格</p><pre><code class="hljs c++">Stack&lt;Stack&lt;<span class="hljs-keyword">int</span>&gt; &gt; intStackStack; <span class="hljs-comment">// OK with all C++ versions</span></code></pre><p>如果你不这么做，<code>&gt;&gt;</code> 会被解析成调用 <code>&gt;&gt;</code> 运算符，这会导致语法错误：</p><pre><code class="hljs c++">Stack&lt;Stack&lt;<span class="hljs-keyword">int</span>&gt;&gt; intStackStack;  <span class="hljs-comment">// ERROR before C++11</span></code></pre><p>这种旧行为使用的原因是，它可以帮助编译器在第一次 pass 源码时，不依赖语意就能对源代码进行正确的标记。但是，漏掉空格是一个很典型的 <code>bug</code>，需要有相关的错误信息，所以对代码语意分析已经被越来越多地考虑进来。因此，从 C++11 开始，通过 “angle bracket hack”技术（<a href>13.3.1 节（未写）会讨论到</a>），两个相邻的模板尖括号之间就不需要在用空格隔开了。</p><h2 id="2-3-类模板的局部使用"><a href="#2-3-类模板的局部使用" class="headerlink" title="2.3. 类模板的局部使用"></a>2.3. 类模板的局部使用</h2><p>一个类模板通常会对用来实例化的模板参数进行多种操作（包含构造函数和析构函数）。这可能会让你以为，要为模板参数提供所有被模板成员函数用到的操作。但是事实不是这样：模板参数只需要提供那些会被用到的操作（而不是可能会被用到的操作）。</p><p>比如 <code>Stack&lt;&gt;</code> 类可能提供了一个成员函数 <code>PrintOn()</code> 来打印整个 stack 的内容，它会调用 <code>operator &lt;&lt;</code> 来依次打印每一个元素：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span><span class="hljs-class">&#123;</span>    ...<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printOn</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream&amp; strm)</span> <span class="hljs-keyword">const</span> </span><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">for</span> (T <span class="hljs-keyword">const</span>&amp; elem : elems)     &#123;strm &lt;&lt; elem &lt;&lt; <span class="hljs-string">' '</span>; <span class="hljs-comment">// call &lt;&lt; for each element</span>&#125;&#125;&#125;;</code></pre><p>你仍然可以使用那些没有提供 <code>operator &lt;&lt;</code> 运算符的元素：</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-built_in">std</span>::pair&lt; <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; ps; <span class="hljs-comment">// std::pair&lt;&gt; 没有定义 operator&lt;&lt;</span>ps.push(&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;); <span class="hljs-comment">// OK</span>ps.push(&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;); <span class="hljs-comment">// OK</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ps.top().first &lt;&lt; <span class="hljs-string">'\n'</span>;  <span class="hljs-comment">// OK</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ps.top().second &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span></code></pre><p>只有在调用 <code>printOn()</code> 的时候，才会导致错误，因为它无法为这一类型实例化出对 <code>operator&lt;&lt;</code> 的调用：</p><pre><code class="hljs c++">ps.printOn(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>); <span class="hljs-comment">// ERROR: 此元素类型不支持 operator&lt;&lt;</span></code></pre><h3 id="2-3-1-Concept"><a href="#2-3-1-Concept" class="headerlink" title="2.3.1 Concept"></a>2.3.1 Concept</h3><p>这样就有一个问题：我们如何才能知道为了实例化一个模板需要哪些操作？名词 <strong><em>concept</em></strong> 通常被用来表示一组反复被模板库要求的限制条件。例如 C++ 标准库是基于这样一些 concepts 的：<strong>可随机进入的迭代器(random access iterator)</strong>和<strong>可默认构造的(default constructible)</strong>。</p><p>目前（C++17），concepts 还只是或多或少的出现在文档当中（比如代码注释）。这会导致严重的问题，因为不遵守这些限制会导致让人难以理解的错误信息（<a href>参考 9.4 节（未写）</a>）。近年来有一些方法和尝试，试图在语言特性层面支持对 <em>concepts</em> 的定义和检查。但是直到 C++17，还没有哪一种方法得以被标准化。从 C++11 开始，你至少可以通过关键字 <code>static_assert</code> 和其它一些预定义的 <em>type traits</em> 来做一些简单的检查。比如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_default_constructible&lt;T&gt;::value,<span class="hljs-string">"Class C requires default-constructible elements"</span>);...&#125;;</code></pre><p>即使没有这个 <code>static_assert</code>，如果需要 <code>T</code> 的默认构造函数的话，依然会遇到编译错误。只不过这个错误信息可能会包含整个模板实例化过程中所有的历史信息，从实例化被触发的地方直到模板定义中引发错误的地方（<a href>参见 9.4 节（未写）</a>）。</p><p>然而还有更复杂的情况需要检查，比如模板类型 <code>T</code> 的实例需要提供一个特殊的成员函数，或者需要能够通过<code>operator &lt;</code> 进行比较。这一类情况的详细例子<a href>请参见 19.6.3 节（未写）</a>。</p><p>C++20 增加对 <em>Concept</em> 的支持，笔者能力有限就不叙述了，请自行查阅 <a href="https://en.cppreference.com/w/cpp/language/constraints" target="_blank" rel="noopener">cpp reference</a> 了解。</p><h2 id="2-4-友元"><a href="#2-4-友元" class="headerlink" title="2.4. 友元"></a>2.4. 友元</h2><p>相比于通过 <code>printOn()</code> 来打印 stack 的内容，更好的办法是去重载 stack 的 <code>operator &lt;&lt;</code> 运算符。而且和非模板类的情况一样，<code>operator&lt;&lt;</code> 应该被实现为非成员函数，在其实现中可以调用 <code>printOn()</code>：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span><span class="hljs-class">&#123;</span>...<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printOn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream&amp; strm)</span> <span class="hljs-keyword">const</span> </span><span class="hljs-function">    </span>&#123;        ...    &#125;    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream&amp; strm,                                    Stack&lt;T&gt;<span class="hljs-keyword">const</span>&amp; s)     &#123;        s.printOn(strm);        <span class="hljs-keyword">return</span> strm;    &#125;&#125;;</code></pre><p>注意在这里 <code>Stack&lt;&gt;</code> 的 <code>operator&lt;&lt;</code> 并不是一个函数模板（对于在模板类内定义这一情况），而是在需要的时候，随类模板实例化出来的一个常规函数。</p><p>但是如果想要在类外定义友元函数的话，就比较复杂了。实际上，我们有两种选择：</p><ol><li><p>我们可以隐式地定义一个新的函数模板，并使用不同的模板参数，比如 <code>U</code> ：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><span class="hljs-class">&#123;</span>    ...    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream&amp;, Stack&lt;U&gt; <span class="hljs-keyword">const</span>&amp;);&#125;;</code></pre><p>无论是继续使用 <code>T</code> 抑或省略模板参数声明，<strong>都不可行</strong>（因为内部的 <code>T</code> 覆盖了外部的 <code>T</code>，或者在当前命名空间域内定义了一个非模板函数）。</p></li><li><p>也可以现将 <code>Stack&lt;T&gt;</code> 的输出运算符声明为一个模板，这需要我们先要对 <code>Stack&lt;T&gt;</code> 进行声明：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>;</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream&amp;, Stack&lt;T&gt; <span class="hljs-keyword">const</span>&amp;);</code></pre><p>接着我们就可以为这一模板函数声明为 <code>Stack&lt;T&gt;</code> 的友元：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span><span class="hljs-class">&#123;</span>    ...    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; &lt;T&gt; (<span class="hljs-built_in">std</span>::ostream&amp;, Stack&lt;T&gt; <span class="hljs-keyword">const</span>&amp;);&#125;;</code></pre><p>注意这里在 <code>operator&lt;&lt;</code> 后面用了 <code>&lt;T&gt;</code>，这相当于声明了一个特化的非成员函数模板作为友元。如果没有 <code>T</code> 就相当于定义了一个新的非模板函数。<a href>具体细节请见 12.5.2 节（未写）</a>。</p></li></ol><p>无论如何，你依然可以使用这个没有定义 <code>operator&lt;&lt;</code> 的类模板，只是你在调用 <code>operator&lt;&lt;</code> 的时候会遇到错误：</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-built_in">std</span>::pair&lt; <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; ps; <span class="hljs-comment">// std::pair&lt;&gt; has no operator&lt;&lt; defined</span>ps.push(&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;); <span class="hljs-comment">// OK</span>ps.push(&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;); <span class="hljs-comment">// OK</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ps.top().first &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ps.top().second &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ps &lt;&lt; ’\n’; <span class="hljs-comment">// ERROR: operator&lt;&lt; not supported for element type</span></code></pre><h2 id="2-5-类模板特化"><a href="#2-5-类模板特化" class="headerlink" title="2.5. 类模板特化"></a>2.5. 类模板特化</h2><p>你可以对类模板的确定的模板参数进行特化。这和重载函数模板类似（<a href="https://vinkle.top/2020/07/09/cpp-template-1/#1-5-重载函数模板" target="_blank" rel="noopener">参考1.5节</a>），类模板特化允许你对一特定的类型进行优化，或者修正类模板对于一特定类型实例化后的一些行为。不过，如果你优化了类模板，你必须也优化所有成员函数。虽然允许值特例化类模板的一个成员函数，不过一旦你这么做的话，你就无法再特化其他成员了。</p><p>为了特化一个类模板，你必须在类声明之前加上 <code>template &lt;&gt;</code>， 并且显式地指出需要特化的类型。这些特化的类型作为模板参数，并且必须紧跟在类名之后：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;std::string&gt;</span><span class="hljs-class">&#123;</span>    ...&#125;;</code></pre><p>对于这些特化的模板，所有的成员函数都应该被定义为“常规”成员函数，也就是说，所有出现 <code>T</code> 的地方都需要被替换为特化的类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span> Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;::push(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; elem)&#123;    elems.push_back(elem); <span class="hljs-comment">//append copy of passed elem</span>&#125;</code></pre><p>下面是一个用 <code>std::string</code> 特化 <code>Stack&lt;&gt;</code> 类模板的完整例子：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stack1.hpp"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;std::string&gt;</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; elems; <span class="hljs-comment">// elements</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp;)</span></span>;  <span class="hljs-comment">// push element</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// pop element</span>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// return top element</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// return whether the stack is empty</span>        <span class="hljs-keyword">return</span> elems.empty();    &#125;&#125;;<span class="hljs-keyword">void</span> Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;::push(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; elem)&#123;    elems.push_back(elem); <span class="hljs-comment">// append copy of passed elem</span>&#125;<span class="hljs-keyword">void</span> Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;::pop()&#123;    assert(!elems.empty());    elems.pop_back(); <span class="hljs-comment">// remove last element</span>&#125;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span> &amp;Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;::top() <span class="hljs-keyword">const</span>&#123;    assert(!elems.empty());    <span class="hljs-keyword">return</span> elems.back(); <span class="hljs-comment">// return copy of last element</span>&#125;</code></pre><p>在这个例子中，特化的类在向 <code>push()</code> 传递参数的时候运用了引用语意，对于 <code>std::string</code> 这一类型很有意义，提升了性能（其实最好使用 <em>forwarding reference</em> ， <a href>6.1 节（未写）我们会讨论到</a>）。</p><p>另外一个不同是使用了 <code>deque</code> 而不是 <code>vector</code> 来存储 stack 里面的元素。虽然这么做在这里没有好处，但是它确实说明了模板特例化之后的实现可能和类模板原始的实现有很大不同。</p><h2 id="2-6-偏特化"><a href="#2-6-偏特化" class="headerlink" title="2.6. 偏特化"></a>2.6. 偏特化</h2><p>类模板可以被<strong>偏特化(partial specialization)</strong>。你可以为某些特殊情况提供特殊的实现，不过使用这必须定义某些模板参数。例如，我们可以定义一个特化的 <code>Stack&lt;&gt;</code> 类来专门处理指针：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stack1.hpp"</span></span><span class="hljs-comment">// partial specialization of class Stack&lt;&gt; for pointers:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;T*&gt;</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T*&gt; elems; <span class="hljs-comment">// elements</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T*)</span></span>;  <span class="hljs-comment">// push element</span>    <span class="hljs-function">T* <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;       <span class="hljs-comment">// pop element</span>    <span class="hljs-function">T* <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// return top element</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// return whether the stack is empty</span>        <span class="hljs-keyword">return</span> elems.empty();    &#125;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">void</span> Stack&lt;T*&gt;::push(T *elem)&#123;    elems.push_back(elem); <span class="hljs-comment">// append copy of passed elem</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;T* Stack&lt;T*&gt;::pop()&#123;    assert(!elems.empty());    T* p = elems.back();    elems.pop_back(); <span class="hljs-comment">// remove last element</span>    <span class="hljs-keyword">return</span> p;         <span class="hljs-comment">// and return it (unlike in the general case)</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;T* Stack&lt;T*&gt;::top() <span class="hljs-keyword">const</span>&#123;    assert(!elems.empty());    <span class="hljs-keyword">return</span> elems.back(); <span class="hljs-comment">// return copy of last element</span>&#125;</code></pre><p>通过</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;T*&gt; &#123;</span> &#125;;</code></pre><p>我们定义了一个类模板，它的参数依旧是 <code>T</code>，但是被特化为处理指针的类模板 (<code>Stack&lt;T*&gt;</code>)。</p><p>同样注意，特化后的函数接口可能会有些许不同。在这个例子中， <code>pop()</code> 返回的是一个指针，因此如果这个指针是通过 <code>new</code> 创建的，使用者可以对这个被删除的值使用 <code>delete</code>：</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-keyword">int</span>*&gt; ptrStack; <span class="hljs-comment">// stack of pointers (specialimplementation)</span>ptrStack.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>&#123;<span class="hljs-number">42</span>&#125;);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptrStack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;<span class="hljs-keyword">delete</span> ptrStack.pop();</code></pre><h3 id="多模板参数的偏特化"><a href="#多模板参数的偏特化" class="headerlink" title="多模板参数的偏特化"></a>多模板参数的偏特化</h3><p>类模板也可以特化多个模板参数的关系。比如下面这个类模板：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span><span class="hljs-class">&#123;</span>...&#125;;</code></pre><p>如下的特化都是可以的：</p><pre><code class="hljs c++"><span class="hljs-comment">// partial specialization: both template parameters have same type</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;T,T&gt; </span><span class="hljs-class">&#123;</span>...&#125;;<span class="hljs-comment">// partial specialization: second type is int</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;T,int&gt; </span><span class="hljs-class">&#123;</span>...&#125;;<span class="hljs-comment">// partial specialization: both template parameters are pointer types</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;T1*,T2*&gt; </span><span class="hljs-class">&#123;</span>...&#125;;</code></pre><p>下面的例子展示了各种类模板被使用的情况：</p><pre><code class="hljs c++">MyClass&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt; mif;   <span class="hljs-comment">// uses MyClass&lt;T1,T2&gt;</span>MyClass&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">float</span>&gt; mff; <span class="hljs-comment">// uses MyClass&lt;T,T&gt;</span>MyClass&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">int</span>&gt; mfi;   <span class="hljs-comment">// uses MyClass&lt;T,int&gt;</span>MyClass&lt;<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">float</span>*&gt; mp;  <span class="hljs-comment">// uses MyClass&lt;T1*,T2*&gt;</span></code></pre><p>如果有不止一个特化的模板匹配程度相同的话，这个定义就是有歧义的：</p><pre><code class="hljs c++">MyClass&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m; <span class="hljs-comment">// ERROR: matches MyClass&lt;T,T&gt; and MyClass&lt;T,int&gt;</span>MyClass&lt;<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>*&gt; m; <span class="hljs-comment">// ERROR: matches MyClass&lt;T,T&gt; and MyClass&lt;T1*,T2*&gt;</span></code></pre><p>为了消除第二个歧义，你可以提供一个额外一个偏特化的版本处理相同类型的指针：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;T*, T*&gt;</span><span class="hljs-class">&#123;</span>    ...&#125;;</code></pre><p>更多关于偏特化的信息，<a href>请参见 16.4 节（未写）</a>。</p><h2 id="2-7-缺省类模板参数"><a href="#2-7-缺省类模板参数" class="headerlink" title="2.7. 缺省类模板参数"></a>2.7. 缺省类模板参数</h2><p>就像函数模板一样，你也可以给类模板的模板参数指定默认值。例如，在 <code>Stack&lt;&gt;</code> 类中你可以定义用来容纳元素的容器的类型作为第二个模板参数，使用 <code>std::vector&lt;&gt;</code> 作为默认值：</p><pre><code class="hljs c++"><span class="hljs-comment">//stack3.hpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Cont = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&gt;class Stack &#123;<span class="hljs-keyword">private</span>:    Cont elems;                <span class="hljs-comment">// elements</span>    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; elem)</span></span>;  <span class="hljs-comment">// push element</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                <span class="hljs-comment">// pop element</span>    <span class="hljs-function">T <span class="hljs-keyword">const</span>&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;      <span class="hljs-comment">// return top element</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// return whether the stack is empty</span></span><span class="hljs-function">    </span>&#123;               <span class="hljs-keyword">return</span> elems.empty();    &#125;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Cont&gt;<span class="hljs-keyword">void</span> Stack&lt;T,Cont&gt;::push (T <span class="hljs-keyword">const</span>&amp; elem)&#123;    elems.push_back(elem);     <span class="hljs-comment">// append copy of passed elem</span>&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Cont&gt;<span class="hljs-keyword">void</span> Stack&lt;T,Cont&gt;::pop ()&#123;    assert(!elems.empty());    elems.pop_back();          <span class="hljs-comment">// remove last element</span>&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Cont&gt;T <span class="hljs-keyword">const</span>&amp; Stack&lt;T,Cont&gt;::top () <span class="hljs-keyword">const</span>&#123;    assert(!elems.empty());    <span class="hljs-keyword">return</span> elems.back();       <span class="hljs-comment">// return copy of last element</span>&#125;</code></pre><p>注意现在有两个模板参数，因此每个成员函数的定义也应该包含两个模板参数：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Cont&gt;<span class="hljs-keyword">void</span> Stack&lt;T,Cont&gt;::push (T <span class="hljs-keyword">const</span>&amp; elem)&#123;    elems.push_back(elem);     <span class="hljs-comment">// append copy of passed elem</span>&#125;</code></pre><p>你可以想之前一样使用 <code>Stack&lt;&gt;</code>。如果你只提供第一个模板参数的类型，那么 <code>vector</code> 会用来处理 <code>Stack&lt;&gt;</code> 中的元素：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Cont = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&gt;class Stack &#123;<span class="hljs-keyword">private</span>:Cont elems; <span class="hljs-comment">// elements</span>    ...&#125;;</code></pre><p>另外，你也可以指定 stack 使用的容器的类型：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stack3.hpp"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">// stack of ints:</span>  Stack&lt;<span class="hljs-keyword">int</span>&gt; intStack;  <span class="hljs-comment">// stack of doubles using a std::deque&lt;&gt; to manage the elements</span>  Stack&lt;<span class="hljs-keyword">double</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt; dblStack;  <span class="hljs-comment">// manipulate int stack</span>  intStack.push(<span class="hljs-number">7</span>);  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; intStack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;  intStack.pop();  <span class="hljs-comment">// manipulate double stack</span>  dblStack.push(<span class="hljs-number">42.42</span>);  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; dblStack.top() &lt;&lt; <span class="hljs-string">'\n'</span>;  dblStack.pop();&#125;</code></pre><p>通过 <code>Stack&lt;double, std::deque&lt;double&gt;&gt;</code></p><p>你定义了存储  <code>double</code> 类型的 <em>stack</em>，其使用的容器是 <code>std::deque&lt;&gt;</code>。</p><h2 id="2-8-类型别名"><a href="#2-8-类型别名" class="headerlink" title="2.8. 类型别名"></a>2.8. 类型别名</h2><p>你可以为类模板定义一个别名，从而更方便地使用它。</p><h3 id="Typedefs-and-Alias-Declarations"><a href="#Typedefs-and-Alias-Declarations" class="headerlink" title="Typedefs and Alias Declarations"></a>Typedefs and Alias Declarations</h3><p>你有两种方式可以为模板定义一个新名称：</p><ol><li><p>使用关键字 <code>typedef</code>：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> Stack&lt;<span class="hljs-keyword">int</span>&gt; IntStack; <span class="hljs-comment">//typedef</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(IntStack <span class="hljs-keyword">const</span>&amp; s)</span></span>; <span class="hljs-comment">//s is stack of ints</span>IntStack istack[<span class="hljs-number">10</span>];         <span class="hljs-comment">//istack is array of 10 stacks of ints</span></code></pre></li><li><p>通过使用关键字 <code>using</code>（C++11 开始）：</p><pre><code class="hljs c++"><span class="hljs-keyword">using</span> IntStack = Stack&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">//alias declaration</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(IntStack <span class="hljs-keyword">const</span>&amp; s)</span></span>; <span class="hljs-comment">//s is stack of ints</span>IntStack istack[<span class="hljs-number">10</span>];         <span class="hljs-comment">//istack is array of 10 stacks of ints</span></code></pre><p>按照 [<strong><em>DosReisMarcusAliasTemplates</em></strong>] 的说法，这一过程叫做 <strong><em>alias declaration</em></strong>。</p></li></ol><p>注意在这两种情况下我们都只是为一个已经存在的类型定义了一个新的名称，并没有重新定义一个新类型。因此在 <code>typedef Stack&lt;int&gt; IntStack;</code> 或者 <code>using IntStack = Stack&lt;int&gt;;</code> 之后，<code>IntStack</code> 和 <code>Stack&lt;int&gt;</code> 是两个对于同一类型的等效的符号。</p><p>作为可用来为已存在类型定义别名的两种方式，都称为 <strong><em>type alias declaration</em></strong>。这个新的名称被称为 <strong><em>type alias</em></strong>。</p><p>由于使用 <strong><em>alias declaration</em></strong> （使用 <code>using</code>，新的名称在 <code>=</code> 符号的左侧）可读性更好，所以我们优先使用这种方法。</p><h3 id="Alias-Templates"><a href="#Alias-Templates" class="headerlink" title="Alias Templates"></a>Alias Templates</h3><p>不同于 <code>typedef</code>，<strong><em>alias declaration</em></strong> 可以被模板化。这样就可以为一组类型取一个方便的名称。这一特性从 C++11 开始生效，被称为 <strong><em>alias templates</em></strong>。</p><p>下面例子中的 <strong><em>alias template</em></strong> <code>DequeStack</code> 是被模板参数 <code>T</code> 参数化的，代表 <code>Stack</code> 中的元素存储在 <code>std::deque</code> 容器中：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">using</span> DequeStack = Stack&lt;T, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;T&gt;&gt;;</code></pre><p>因此，类模板和 <strong><em>alias templates</em></strong> 都是可以被参数化的类型。同样的，<strong><em>alias template</em></strong> 只是简单地给一个已经存在的类型一个新名字，原来的类型名还是可以使用的。<code>DequeStack&lt;int&gt;</code> 和 <code>Stack&lt;int, std::deque&lt;int&gt;&gt;</code> 代表了同一个类型。</p><p>再次注意，模板只可以被定义在 <em>global/namespace scope</em> 或者在类的声明之中。</p><h3 id="Alias-Templates-for-Member-Types"><a href="#Alias-Templates-for-Member-Types" class="headerlink" title="Alias Templates for Member Types"></a>Alias Templates for Member Types</h3><p>使用 <strong><em>alias templates</em></strong> 可以很方便的给类模板的成员类型一个<strong>快捷名称(short cut)</strong>：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyType</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">typedef</span> ... iterator;    ...&#125;;</code></pre><p>或者</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyType</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">using</span> iterator = ...;    ...&#125;;</code></pre><p>之后，下面这样的定义:</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">using</span> MyTypeIterator = <span class="hljs-keyword">typename</span> MyType&lt;T&gt;::iterator;</code></pre><p>允许我们使用  <code>MyTypeIterator&lt;int&gt; pos;</code> 来取代 <code>typename MyType&lt;T&gt;::iterator pos;</code>。</p><h3 id="Type-Traits-Sufflix-t"><a href="#Type-Traits-Sufflix-t" class="headerlink" title="Type Traits Sufflix_t"></a>Type Traits Sufflix_t</h3><p>从 C++14 开始，标准库使用这一技术为所有的 <em>type trait</em> 定义了一个<strong>快捷名称(short cut)</strong>。比如能用这种写法</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_const_t</span>&lt;T&gt; <span class="hljs-comment">// since C++14</span></code></pre><p>来替代</p><pre><code class="hljs c++"><span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::add_const&lt;T&gt;::type <span class="hljs-comment">// since C++11</span></code></pre><p>标准库做了如下的定义：</p><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>&#123;    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">add_const_t</span> = <span class="hljs-keyword">typename</span> add_const&lt;T&gt;::type;&#125;</code></pre><h2 id="2-9-类模板参数推导"><a href="#2-9-类模板参数推导" class="headerlink" title="2.9. 类模板参数推导"></a>2.9. 类模板参数推导</h2><p>在 C++17 之前，使用类模板时必须显式地支持所有模板参数的类型（除非它们有默认值）。C++17 开始，这一要求就没有那么严格了。如果类模板的构造函数可以推导出所有的参数类型（不含有默认值的），就不必需要显式地指明模板参数的类型了。</p><p>比如在前面的例子中，你可以使用拷贝构造函数而不指定模板参数的参数类型：</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-keyword">int</span>&gt; intStack1;             <span class="hljs-comment">// stack of strings</span>Stack&lt;<span class="hljs-keyword">int</span>&gt; intStack2 = intStack1; <span class="hljs-comment">// OK in all versions</span>Stack intStack3 = intStack1;      <span class="hljs-comment">// OK since C++17</span></code></pre><p>通过提供一个接受初始参数的构造函数，就可以推导出 stack 元素的类型。例如我们可以定义一个可以被一个参数初始化的 stack：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; elems; <span class="hljs-comment">// elements</span><span class="hljs-keyword">public</span>:Stack () = <span class="hljs-keyword">default</span>;Stack (T <span class="hljs-keyword">const</span>&amp; elem) <span class="hljs-comment">// initialize stack with one element</span>: elems(&#123;elem&#125;) &#123;&#125;...&#125;;</code></pre><p>然后你就可以像这样声明一个 stack：</p><pre><code class="hljs c++">Stack intStack = <span class="hljs-number">0</span>; <span class="hljs-comment">// 被推导为 Stack&lt;int&gt;，从 C++17 开始</span></code></pre><p>通过用整数 <code>0</code> 来初始化 <code>Stack</code> 类型时，模板参数 <code>T</code> 被推导为 <code>int</code>，这样就实例化出一个 <code>Stack&lt;int&gt;</code>。</p><p>注意下面这些细节：</p><ul><li><p>由于定义了接受 <code>int</code> 类型的模板构造函数，你需要请求一个默认的构造函数及其默认行为，这是因为默认构造函数只有在其他构造函数没有定义时才会生成，方法如下：</p>  <pre><code class="hljs c++">Stack() = <span class="hljs-keyword">default</span>;</code></pre></li><li><p>参数 <code>elem</code> 传递给 <code>elems</code> 时用大括号 <code>{}</code> 包裹起来，通过<strong>初始化列表(initializer list)</strong>的方式只用一个参数初始化 <code>vector</code> 类型的 <code>elems</code>: </p><pre><code class="hljs c++">: elems(&#123;elem&#125;);</code></pre><p>这是因为 <code>vector</code> 类型没有用一个参数直接初始化元素的构造函数。</p></li></ul><p>注意，不同于函数模板，类模板参数可能无法部分推导其类型（通过显式地指明其中一部分模板参数的类型）。<a href>参见 15.12 节（未写）</a>。</p><h3 id="类模板对字符串常量的参数推导："><a href="#类模板对字符串常量的参数推导：" class="headerlink" title="类模板对字符串常量的参数推导："></a>类模板对字符串常量的参数推导：</h3><p>原则上，你甚至可以通过字符串常量来初始化 stack：</p><pre><code class="hljs c++">Stack stringStack = <span class="hljs-string">"bottom"</span>; <span class="hljs-comment">// 被推导为 Stack&lt;char const[7]&gt;，从 C++17 开始</span></code></pre><p><strong>但是</strong>，这会带来一大堆问题：一般，当通过引用来传递模板类型 <code>T</code> 的参数是，这个参数类型不会被 <em>decay</em> (将 raw array 转换为相应的 raw pointer)。这说明我们的确定义了这个类型的 <code>Stack</code>:</p><pre><code class="hljs c++">Stack&lt;<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>[<span class="hljs-number">7</span>]&gt;</code></pre><p>当使用 <code>T</code> 的时候都会被实例化为 <code>char const[7]</code>。这样我们就不能放入不同长度的字符串了，因为这是不同的类型。详细的讨论<a href>参见 7.4 节（未写）</a>。</p><p>但是，如果我们按值传递模板参数 <code>T</code> 的话，参数类型就会被 <em>decay</em> ，也就是将 <em>raw array</em> 转换为相应的 <em>raw pointer</em> 。这样，调用带有模板参数 <code>T</code> 的构造函数就会将模板参数 <code>T</code> 的类型推导成 <code>char const*</code>，模板也被推导为 <code>Stack&lt;char const*&gt;</code>。</p><p>基于以上原因，可能有必要讲构造函数声明成按值传递参数的形式：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; elems; <span class="hljs-comment">// elements</span><span class="hljs-keyword">public</span>:Stack (T elem) <span class="hljs-comment">// initialize stack with one element by value</span>: elems(&#123;elem&#125;) &#123;&#125; <span class="hljs-comment">// to decay on class tmpl arg deduction</span>...&#125;;</code></pre><p>这样下面的初始化方式就可以正常运行：</p><pre><code class="hljs c++">Stack stringStack = <span class="hljs-string">"bottom"</span>; <span class="hljs-comment">// Stack&lt;char const*&gt; deduced since C++17</span></code></pre><p>在这个例子中，我们最好使用 <em>move</em> 将临时变量 <code>elem</code> 添加至 stack 中，避免不必要的拷贝：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; elems; <span class="hljs-comment">// elements</span><span class="hljs-keyword">public</span>:Stack (T elem) <span class="hljs-comment">// initialize stack with one element by value</span>: elems(&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(elem)&#125;) &#123;&#125; ...&#125;;</code></pre><h3 id="推导指引-Deduction-Guides"><a href="#推导指引-Deduction-Guides" class="headerlink" title="推导指引(Deduction Guides)"></a>推导指引(Deduction Guides)</h3><p>除了将构造函数声明成按值传递，还有一个解决方案：因为在容器中处理 <em>raw pointers</em> 可能会导致很多问题，我们应该禁止容器类将类型自动推导成 <em>raw character pointers</em>。</p><p>我们可以通过定义推导指引来提供额外的模板参数推导规则，或者修改已有的模板参数推导规则。例如，你可以定义当一个字符串常量或者 C 类型字符串被传递时，stack 类型被实例化为 <code>std::string</code>：</p><pre><code class="hljs c++">Stack(<span class="hljs-keyword">char</span> cosnt*) -&gt; Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;;</code></pre><p>这个指引语句也必须出现在模板类定义的 <em>scope(namespace)</em> 内。通常它紧跟着模板类的定义。<code>-&gt;</code> 后面的类型被称为<strong>推导指引(deduction guide)</strong>的 <em>guided type</em>。</p><p>现在，根据这个定义</p><pre><code class="hljs c++">Stack stringStackStack stringStack&#123;<span class="hljs-string">"bottom"</span>&#125;; <span class="hljs-comment">// OK: Stack&lt;std::string&gt; deduced since C++17</span></code></pre><p>stack 被推导为 <code>Stack&lt;std::string&gt;</code>。但是，下面的语句仍旧是无效的：</p><pre><code class="hljs c++">Stack stringStack = <span class="hljs-string">"bottom"</span>; <span class="hljs-comment">// Stack&lt;std::string&gt; deduced, but still not valid</span></code></pre><p>模板参数类型被推导为 <code>std::string</code>，也实例化出了 <code>Stack&lt;std::string&gt;</code>：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; elems; <span class="hljs-comment">// elements</span><span class="hljs-keyword">public</span>:Stack (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; elem) <span class="hljs-comment">// initialize stack with one element</span>: elems(&#123;elem&#125;) &#123;&#125;...&#125;;</code></pre><p>但是根据语言规则，除了 <code>std::string</code>，你不能对字符串常量使用拷贝初始化（用 <code>=</code> 初始化）来初始化一个对象。因此你必须用如下的初始化方式：</p><pre><code class="hljs c++">Stack stringStack&#123;<span class="hljs-string">"bottom"</span>&#125;; <span class="hljs-comment">// Stack&lt;std::string&gt; deduced and valid</span></code></pre><p>跟类模板参数推导类似，在声明 <code>stringStack</code> 的类型是 <code>Stack&lt;std::string&gt;</code> 之后，下面的初始化声明了同一个类型（调用拷贝构造函数）而不是用类型为 <code>Stack&lt;std::string&gt;</code> 的元素对 stack 进行初始化（推导出的类型不会是 <code>Stack&lt;std::string&gt;</code>）：</p><pre><code class="hljs c++">Stack stack2&#123;stringStack&#125;;    <span class="hljs-comment">// Stack&lt;std::string&gt; deduced</span><span class="hljs-function">Stack <span class="hljs-title">stack3</span><span class="hljs-params">(stringStack)</span></span>;    <span class="hljs-comment">// Stack&lt;std::string&gt; deduced</span>Stack stack4 = &#123;stringStack&#125;; <span class="hljs-comment">// Stack&lt;std::string&gt; deduced</span></code></pre><p>更多内容，<a href>参见 15.12 节（未写）</a>。</p><h2 id="2-10-模板聚合"><a href="#2-10-模板聚合" class="headerlink" title="2.10. 模板聚合"></a>2.10. 模板聚合</h2><p>聚合类（<em>classes/structs</em> which没有用户定义的显式的或者是继承的构造函数，没有 private 或者 protected 的非静态成员，没有虚函数，没有 virtual, private, or protected 方式继承的父类）也可以是模板。例如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValueWithComment</span> </span><span class="hljs-class">&#123;</span>T value;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> comment;&#125;;</code></pre><p>定义了一个成员 <code>value</code> 的类型被参数化了的聚合类。可以像定义其它类模板的对象一样定义一个聚合类的对象：</p><pre><code class="hljs c++">ValueWithComment&lt;<span class="hljs-keyword">int</span>&gt; vc;vc.value = <span class="hljs-number">42</span>;vc.comment = <span class="hljs-string">"initial value"</span>;</code></pre><p>从C++17 开始，可以为聚合类的类模板定义推导指引：</p><pre><code class="hljs c++">ValueWithComment(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>*, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>*)     -&gt; ValueWithComment&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;;ValueWithComment vc2 = &#123;<span class="hljs-string">"hello"</span>, <span class="hljs-string">"initial value"</span>&#125;;</code></pre><p>没有“推导指引”的话，就不能使用上述初始化方法，因为 <code>ValueWithComment</code> 没有相应的构造函数来完成相关类型推导。</p><p>标准库的 <code>std::array&lt;&gt;</code> 类也是一个聚合类，其元素类型和尺寸都是被参数化的。C++17 也给它定义了“推导指引”，<a href>在 4.4.4 节（未写）会做进一步讨论</a>。</p><h2 id="2-11-小结"><a href="#2-11-小结" class="headerlink" title="2.11. 小结"></a>2.11. 小结</h2><ul><li>类模板是有一个或者多个参数待定的类</li><li>使用类模板是，你需要传递模板参数的类型，之后类模板会对这些类型进行实例化。</li><li>对于类模板，成员函数只有被使用时才会被实例化。</li><li>你可以针对特定类型对类模板特化。</li><li>你可以针对特定类型对类模板偏特化。</li><li>从 C++17 开始，类模板的模板参数可以通过其构造函数进行自动推导。</li><li>你可以定义聚合类的类模板</li><li>调用参数如果是按值传递的话，相应的模板类型会被 <em>decay</em>.</li><li>模板只可以被定义在 <em>global/namespace scope</em> 或者在类的声明之中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Template</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2020/07/15/union-find/"/>
    <url>/2020/07/15/union-find/</url>
    
    <content type="html"><![CDATA[<p>并查集是一种树型的数据结构，主要用于处理一些不交集的合并及查询问题。本文通过样例介绍了并查集，并给出了 C++ 算法的实现和两种优化方案。</p><a id="more"></a><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>在计算机科学中，并查集是一种树型的数据结构，主要用于处理一些<strong>不交集（Disjoint Sets）</strong>的合并及查询问题。有一个<strong>联合-查找算法（Union-find Algorithm）</strong>定义了两个用于此数据结构的操作：</p><ul><li><code>Find</code>：确定元素属于哪一个子集。它用来确定两个元素是否属于同一子集。</li><li><code>Union</code>：将两个子集合并成同一个几何。</li></ul><p>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，<code>Find(x)</code> 返回 <code>x</code> 所属集合的代表，而 <code>Union</code> 使用两个集合的代表作为参数。</p><h2 id="并查集介绍和实现"><a href="#并查集介绍和实现" class="headerlink" title="并查集介绍和实现"></a>并查集介绍和实现</h2><p>市场上原来有 $1,2,3,4,5,6$ 这六家公司，各自经营着自己的生意。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/1.png" srcset="/img/loading.gif" alt></p><p>有一天，$4$ 找到了 $1$ 说，最近形式不大好，要不我们两家公司合并成一家，$4$ 觉得自己的名字不够气派，就跟着 $1$ 叫同一个名字了。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/2.png" srcset="/img/loading.gif" alt></p><p>过了不久，$2$ 也想着找人合作，就找到了 $4$，$4$ 说我已经改叫 $1$ 了，你跟我和合作就是跟 $1$ 合作，$2$ 和 $1$ 商量了一下，$2$ 也觉得自己的名字不好听，也改成 $1$ 的名字了。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/3.png" srcset="/img/loading.gif" alt></p><p>$3,6$ 一看市场形势，也开始和 $5$ 商量起了合并的事宜，他们决定最后名字就是 $5$ 了。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/4.png" srcset="/img/loading.gif" alt></p><p>可是 $5$ 合并的太晚了， 已经临近破产，$2$ 公司看到机会跟 $6$ 公司商量事宜，其实最后就是 $1$ 和 $5$ （他们合并后的公司）商量，结果 $5$ 很无奈，被合并了，最后所有公司归为 $1$ 管理了。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/5.png" srcset="/img/loading.gif" alt></p><p>其实这个合并的图是一个<strong>树状结构</strong>，寻找每个集合的代表元素，只要层层向上访问<strong>父节点</strong>搜索即可，直到到达树的<strong>根节点</strong>。根节点的父节点是它自身。我们可以直接把这幅图表示成一棵树。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/6.png" srcset="/img/loading.gif" alt></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>根据上面例子的步骤，我们可以轻松写出简单版本的并查集代码。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code class="hljs c++"><span class="hljs-keyword">int</span> root[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        root[i] = i;&#125;</code></pre><p>我们用 <code>root</code> 数组存储每个节点的父节点， 刚开始，先把所有节点的父节点初始化为自己。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root[x] == x)        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(root[x]);&#125;</code></pre><p>查询这个节点的根节点时，我们使用递归的思想：一层一层访问该节点的父节点，直到访问到根节点（即父节点是自身）。</p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    root[<span class="hljs-built_in">find</span>(i)] = <span class="hljs-built_in">find</span>(j);&#125;</code></pre><p>合并两个节点也很节点，只要把其中一个的根节点的父节点设置为另一个的父节点即可。</p><h2 id="优化并查集"><a href="#优化并查集" class="headerlink" title="优化并查集"></a>优化并查集</h2><p>前面说的简单的并查集其实效率比较低。</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>我们可以看以下场景：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/7.png" srcset="/img/loading.gif" alt></p><p>我们进行 <code>merge(2,3)</code> 和 <code>merge(2,4)</code> 操作后，图变为如下：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/8.png" srcset="/img/loading.gif" alt></p><p>这是一条长链，随着节点的不断增多，这条链会越来越长，我们从链最底部找到其根节点的消耗也越来越多。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/9.png" srcset="/img/loading.gif" alt></p><p>如果图是这样的，我们就不必层层查询根节点了。</p><p>那么怎么实现呢？我们可以使用<strong>路径压缩</strong>的方法，在每次寻找元素根节点的时候，把它的父节点直接设为根节点，这样在下一次查询后，只要一次就能找到根节点了。</p><p>同样用递归的方式，把沿途的父节点全设置为根节点：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (x != root[x])    &#123;        root[x] = <span class="hljs-built_in">find</span>(root[x]);    &#125;    <span class="hljs-keyword">return</span> root[x];&#125;</code></pre><h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>由于路径压缩只对访问过的路径进行压缩，不是每个节点的父节点都是根节点。所以并查集的结构仍然可能是负载的。看下面的情形：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/10.png" srcset="/img/loading.gif" alt></p><p>$8$ 要和 $7$ 合并，这是我们有两种方案，$7$ 作为 $8$ 的父节点和 $8$ 作为 $7$ 的父节点这两种方式：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/union_find/13.png" srcset="/img/loading.gif" alt></p><p>显然第一种方式效率更加高。</p><p>因为如果把  $8$ 作为 $7$ 的父节点，会使得数的<strong>深度</strong>（树中最长链的长度）加深，原来树的每个节点到根的距离都变长了，后面我们每次查询根节点复杂度也会变高。而把 $7$ 作为 $8$ 的父节点就不会有这个问题。因此我们每次合并的时候都应该把简单的树合并到复杂的树上面，保证每次合并到根节点距离变长的节点数量最少。</p><p>运用这个思想我们可以写出相关的代码。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>我们用 <code>rank</code> 数组来表示每个根节点对应的树的深度。一开始将所有的 <code>rank</code> 置为 <code>1</code>。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> rank[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        root[i] = i;        rank[i] = <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h4 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a>合并</h4><p>合并时比较两个根节点的 <code>rank</code> 值，将 <code>rank</code> 小的向 <code>rank</code> 大的树合并。如果两个树深度相同，则合并后新树的 <code>rank</code> 值需要加一。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-built_in">find</span>(i), y = <span class="hljs-built_in">find</span>(j);    <span class="hljs-keyword">if</span> (rank[x] &lt;= rank[y])        root[x] = y;   <span class="hljs-keyword">else</span>        root[y] = x;   <span class="hljs-keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)        rank[y]++;&#125;</code></pre><p>注意路径压缩和按秩合并一起使用时，可能会破坏按秩合并的准确性。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra 算法</title>
    <link href="/2020/07/13/Dijkstra/"/>
    <url>/2020/07/13/Dijkstra/</url>
    
    <content type="html"><![CDATA[<p>Dijkstra 算法是一个最短路径算法，常用于解决非负有权图中的最短路径问题。本文通过示例介绍了 Dijkstra 算法，并给出了 C++ 的算法实现和一种优化策略。</p><a id="more"></a><h1 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Dijkstra 算法通过保留目前为止所找到的每个顶点 $v\in V$从 $s$ 到 $v$ 的最短路径来工作的。初始时，起点 $s$ 的路径权重被赋为 $0\ (dis[s]=0)$，同时把其他路径的长度设为无穷大。当算法结束后，$dis[v]$ 存储的便是从 $s$ 到 $v$ 的最短路径，如果路径不存在，则 $dis[v] = \infty $。</p><p>松弛操作是 $Dijkstra$ 算法的基础操作：如果存在一条从 $u$ 到 $v$ 的边，那么从 $s$ 到 $v$ 的一条新路径就是将边 $w(u,v) \in E$ 添加到从 $s$ 到 $u$ 的路径尾部，拓展出一条从 $s$ 到 $u$ 的路径。这条新路径的长度是 $dis[u] + w(u,v)$。如果这个值比已知的 $dis[v]$ 小，那么可以替换原先的 $dis[v]$，并将 $path[v]$ 的值更改为 $u$。松弛操作已知运行到所有的 $d[v]$ 都代表 $s$ 到 $v$ 的最短路径的长度值。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>直接看介绍可能还不理解，我们可以看如下的图</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/1.png" srcset="/img/loading.gif" alt></p><p>假设起点 $s = 1$，我们将 $s$ 压入路径 $q$ 中， $vis[s] = 1(true)$ ,  $dis[s] = 0$，寻找路径中最近的点 $u$ 即 $u=1$ ，将 $u$ 扔出路径，此时 $u$ 点连通 $v = 2,4,6$ 三点，将 $\{2,4,6\}$ 压入路径 $q$ 中，计算 $w = w(u,v)+dis[u]$，根据 $dis[v] = min(dis[v],w)$ 更新 $dis$ ,此时$dis=\{0,2,\infty,6,\infty,9,\infty,\infty,\infty\}$ ,若 $dis[v]$ 更新，就使 $path[v] = w$ ，此时 $path = \{1,1,0,1,0,1,0,0\}$ 。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/2.png" srcset="/img/loading.gif" alt></p><p>第二次，我们查找路径中与起点 $s$ 距离最近的点$u$ ，此时 $u=2$，同样将 $u$ 扔出路径并将 $vis[u]=1$， 因为$u$ 点连通 $v = 3,4$ 且 $vis[v] = 0 (false)$，所以更新路径 $q=\{3,4,6\}$，更新 $dis=\{0,2,32,3,\infty,9,\infty,\infty\} $，更新$path=\{1,1,2,2,0,1,0,0\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/3.png" srcset="/img/loading.gif" alt></p><p>同理，$u=4$，$vis[u]=1$，$q=\{3,5,6\}$，$dis=\{0,2,32,3,5,9,\infty,\infty\}$，$path=\{1,1,2,2,4,1,0,0\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/4.png" srcset="/img/loading.gif" alt></p><p>同理，$u=5$，$vis[u]=1$，$q=\{3,6,7\}$，$dis=\{0,2,13,3,5,9,12,\infty\}$，$path=\{1,1,5,2,4,1,5,0\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/5.png" srcset="/img/loading.gif" alt></p><p>同理，$u=6$，$vis[u]=1$，$q=\{3,7\}$，$dis=\{0,2,13,3,5,9,12,\infty\}$，$path=\{1,1,5,2,4,1,5,0\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/6.png" srcset="/img/loading.gif" alt></p><p>同理，$u=7$，$vis[u]=1$，$q=\{3,8\}$，$dis=\{0,2,13,3,5,9,12,33\}$，$path=\{1,1,5,2,4,1,5,7\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/7.png" srcset="/img/loading.gif" alt></p><p>同理，$u=3$，$vis[u]=1$，$q=\{8\}$，$dis=\{0,2,13,3,7,9,12,28\}$，$path=\{1,1,5,2,4,1,5,3\}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/8.png" srcset="/img/loading.gif" alt></p><p>最后$u=5$，$vis[u]=1$，$q=\{\}$ 为空，到此 $Dijkstra$ 算法顺利完成！</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/Dijkstra/9.png" srcset="/img/loading.gif" alt></p><h2 id="实现及优化"><a href="#实现及优化" class="headerlink" title="实现及优化"></a>实现及优化</h2><p>首先定义 $dis,vis,path,node$。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> dis[N];<span class="hljs-keyword">bool</span> vis[N];<span class="hljs-keyword">int</span> path[N];stuct node&#123;    <span class="hljs-keyword">int</span> u, v, w;    node(<span class="hljs-keyword">int</span> _u, <span class="hljs-keyword">int</span> _v, <span class="hljs-keyword">int</span> _w):u(_u), v(_v), w(_w)&#123;&#125;    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> node&amp; n) <span class="hljs-keyword">const</span>    &#123;        <span class="hljs-keyword">return</span> v &gt; n.v;    &#125;&#125;;</code></pre><p>初始化 $dis,vis,path$</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        dis[N] = INT_MAX;    &#125;    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-built_in">memset</span>(path,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(path));&#125;</code></pre><p>因为有删除操作，为了减少复杂度，选择了用 <code>std::list&lt;&gt;</code> 来存储路径。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;node&gt;&gt;&amp; vec, <span class="hljs-keyword">int</span> s)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; q;    init();    q.push_back(s);    dis[s] = <span class="hljs-number">0</span>;    path[s] = s;    <span class="hljs-keyword">while</span> (!q.empty())    &#123;        <span class="hljs-keyword">auto</span> k = q.<span class="hljs-built_in">begin</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>(); it != q.<span class="hljs-built_in">end</span>(); it++)        &#123;            <span class="hljs-keyword">if</span> (dis[*it] &lt; dis[*k])                k = it;        &#125;        <span class="hljs-keyword">int</span> v = *k;        q.erase(k);        vis[v] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : vec[v])        &#123;            <span class="hljs-keyword">if</span> (!vis[i.v] &amp;&amp; i.w + dis[v] &lt; dis[i.v])            &#123;                dis[i.v] = i.w + dis[v];                path[i.v] = v;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(q.<span class="hljs-built_in">begin</span>(),q.<span class="hljs-built_in">end</span>(),i.v)==q.<span class="hljs-built_in">end</span>())                    q.push_back(i.v);            &#125;        &#125;    &#125;&#125;</code></pre><p>因为在每次寻找离起点最近的点都要花费 $O(V)$ 的复杂度，所以考虑把点都存在堆中，在 C++ 中一般使用<code>std::priority_queue&lt;&gt;</code>优先队列，将每条边以 $\{u,v,w(u,v)+dis[u]\}$ 的形式压入队列中，队列顶端的元素即为边通向的顶点到起点距离的最小值，此时只要花费 $O(log(E))$ 的复杂度。总体的复杂度从 $O(V^2+E)$ 变为了 $O((E+V)log(E))$，当图为<strong>稀疏图</strong>时，使用堆的算法效率明显更高。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;node&gt;&gt;&amp; vec, <span class="hljs-keyword">int</span> s)</span></span><span class="hljs-function"></span>&#123;    init();    priority_queue&lt;node&gt; q;    q.push(node(s,s,<span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span> (!q.empty())    &#123;        node k = q.top();        q.pop();        <span class="hljs-keyword">if</span>(vis[k.v]) <span class="hljs-keyword">continue</span>;        vis[k.v] = <span class="hljs-literal">true</span>;        dis[k.v] = k.w;        path[k.v] = k.u;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : vec[k.v])        &#123;            q.push(node(i.u, i.v, i.w + dis[i.u]));        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Template-1 函数模板</title>
    <link href="/2020/07/09/cpp-template-1/"/>
    <url>/2020/07/09/cpp-template-1/</url>
    
    <content type="html"><![CDATA[<p>通过大量的例子介绍了C++函数模板。你可以学习到如何使用C++的函数模板以及使用时需要注意的要点。</p><a id="more"></a><p>这是本系列<strong>第一篇</strong>文章，以下是本系列文章目录。</p><p><a href="#1-函数模板">1. 函数模板（本文）</a></p><p><a href="https://vinkle.top/2020/07/17/cpp-template-2/#2-%E7%B1%BB%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">2. 类模板 </a></p><p><a href>3. 非类型模板参数（正在编写）</a></p><h1 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a>1. 函数模板</h1><p>本章介绍了函数模板。函数模板是被参数化的函数，因此他们代表了一组行为相似的函数(a family of functions)。</p><h2 id="1-1-初识函数模板"><a href="#1-1-初识函数模板" class="headerlink" title="1.1. 初识函数模板"></a>1.1. 初识函数模板</h2><p>函数模板提供了适用于不同类型的函数行为。也就是说，函数模板代表了一组行为相似的函数。函数模板看起来几乎就跟普通函数一样，除了某些信息没有被确定以外。我们通过下面一个简单的例子来说明这一问题。</p><h3 id="1-1-1-定义模板"><a href="#1-1-1-定义模板" class="headerlink" title="1.1.1 定义模板"></a>1.1.1 定义模板</h3><p>一下是一个函数模板，它返回两数中的最大值</p><pre><code class="hljs c++"><span class="hljs-comment">//max1.hpp</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>这个模板第一了一系列函数，他们都返回了两个参数中值较大的拿一个。这两个参数的类型并没有确定，而是被表示为<strong>模板参数(template parameter)</strong> <code>T</code>。</p><p>模板参数应该按照如下的语法来声明：</p><p><em>template &lt;由逗号分隔的模板参数&gt;</em></p><p>在本例中，模板参数是 <code>typename T</code> 。关键字 <code>typename</code> 标识了一个<em>类型参数</em>，即 <code>T</code> 是<strong>类型参数(type parameter)</strong>，你可以用任意的标识作为类型参数的参数名，但是习惯上我们使用 <code>T</code> 作为参数名。本例中，类型 <code>T</code> 必须支持小于运算符，因为 <code>a</code> 和 <code>b</code> 比较时运用到了它。另外比较隐秘的一点，为了支持返回值，<code>T</code> 还应该是可拷贝的。</p><h3 id="1-1-2-使用模板"><a href="#1-1-2-使用模板" class="headerlink" title="1.1.2 使用模板"></a>1.1.2 使用模板</h3><p>下面的程序展现了如何使用 <code>max()</code>模板：</p><pre><code class="hljs c++"><span class="hljs-comment">//max1.cpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"max1.hpp"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(7,i): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>,i) &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">double</span> f1 = <span class="hljs-number">3.4</span>;    <span class="hljs-keyword">double</span> f2 = <span class="hljs-number">-6.7</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(f1,f2): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(f1,f2) &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"mathematics"</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"math"</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(s1,s2): "</span> &lt;&lt; ::<span class="hljs-built_in">max</span>(s1,s2) &lt;&lt; <span class="hljs-string">'\n'</span>;&#125;</code></pre><p>注意在调用的 <code>max()</code> 模板的时候使用了作用域限制符 <code>::</code>。这样保证了程序将会在全局<strong>命名空间(namespace)</strong>中查找 <code>max()</code> 模板。</p><p>在此程序中，<code>max()</code>被调用了三次：一次是比较两个<code>int</code>，一次是比较两个<code>double</code>，还有一次是比较两个 <code>std::string</code>。每一次都会算出最大值。下面是输出结果：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-number">7</span>,i)</span></span>: <span class="hljs-number">42</span><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(f1,f2)</span></span>: <span class="hljs-number">3.4</span><span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(s1,s2)</span></span>: mathematics</code></pre><p>在编译阶段，模板并不是被编译成一个可以支持多种类型的实体。而是对每一个用于该模板的类型都会产生一个独立的实体。因此在本例中，<code>max()</code> 会被编译出三个实体，因为它被用于三种类型。比如第一次调用时：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;... <span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, i) ...</code></pre><p>函数模板的类型参数 T 是<code>int</code>。因此在语义上等价于调用如下函数：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>以上用具体类型取代模板类型参数的过程叫做<strong>实例化(instantiation)</strong>。它会产生模板的一个实例。</p><p>值得注意的是，模板的实例化不需要程序员做额外的请求，只是简单的使用函数模板就会触发这一实例化过程。</p><p>同样的，另外两次调用也会分别为 <code>double</code> 和 <code>std::string</code> 各实例化出一个实例，就像是分别定义了下面两个函数一样：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>)</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>)</span></span>;</code></pre><p>另外，只要结果是有意义的，void 作为模板参数也是有效的。比如:</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">foo</span><span class="hljs-params">(T*)</span></span><span class="hljs-function"></span>&#123; &#125;<span class="hljs-keyword">void</span>* vp = <span class="hljs-literal">nullptr</span>;foo(vp); <span class="hljs-comment">// OK: 模板参数被推导为 void</span>foo(<span class="hljs-keyword">void</span>*)</code></pre><h3 id="1-1-3-二阶段翻译-Two-Phase-Translation"><a href="#1-1-3-二阶段翻译-Two-Phase-Translation" class="headerlink" title="1.1.3 二阶段翻译(Two-Phase Translation)"></a>1.1.3 二阶段翻译(Two-Phase Translation)</h3><p>在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误(compile-time error)。比如：</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">complex</span>&lt;<span class="hljs-keyword">float</span>&gt; c1, c2; <span class="hljs-comment">// std::complex&lt;&gt; 没有提供小于运算符</span>...::<span class="hljs-built_in">max</span>(c1,c2); <span class="hljs-comment">// 编译期 ERROR</span></code></pre><p>在编写是不会立刻提醒错误，因为模板是分两步编译的：</p><ol><li><p>在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面：</p><ul><li>语法检查。比如少了分号。</li><li>检查使用未定义的不依赖于模板参数的未知名称（类型名，函数名，…）。</li><li>检查不依赖于模板参数的<strong>静态断言(static assertion)</strong>；</li></ul></li><li><p>在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。</p><p>例如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span><span class="hljs-function"></span>&#123;    undeclared(); <span class="hljs-comment">// 如果 undeclared() 未定义，第一阶段就会报错</span>    undeclared(t); <span class="hljs-comment">//如果 undeclared(t) 未定义，第二阶段会报错</span>    <span class="hljs-keyword">static_assert</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &gt; <span class="hljs-number">10</span>,<span class="hljs-string">"int too small"</span>); <span class="hljs-comment">// 总是报错</span>    <span class="hljs-keyword">static_assert</span>(<span class="hljs-keyword">sizeof</span>(T) &gt; <span class="hljs-number">10</span>, <span class="hljs-string">"T too small"</span>); <span class="hljs-comment">//只会在第二阶段报错</span>&#125;</code></pre></li></ol><p>需要注意的是，有些编译器并不会执行第一阶段中的所有检查。因此如果模板没有被至少实例化一次的话，你可能一直都不会发现代码中的常规错误。</p><h4 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h4><p>两阶段的编译检查给模板的处理带来了一个问题：当实例化一个模板的时候，编译器需要（一定程度上）看到模板的完整定义。这不同于函数编译和链接分离的思想，函数在编译阶段只需要声明就够了。后面将讨论如何应对这一问题。现在暂时采取最简单的方法：将模板的实现写在头文件里。</p><h2 id="1-2-模板参数推导"><a href="#1-2-模板参数推导" class="headerlink" title="1.2. 模板参数推导"></a>1.2. 模板参数推导</h2><p>当我们调用形如 <code>max()</code> 的函数模板来处理某些变量时，模板参数将由被传递的调用参数决定。如果我们传递两个 <code>int</code> 类型的参数给模板函数，C++编译器会将模板参数 T 推导为 <code>int</code>。</p><p>不过 T 可能只是实际传递的函数参数类型的一部分。比如我们定义了如下接受常量引用作为函数参数的模板：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; a, T <span class="hljs-keyword">const</span>&amp; b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>此时如果我们传递 <code>int</code> 类型的调用参数，由于调用参数和 <code>int const &amp;</code> 匹配，类型参数 T 将被推导为<code>int</code>。</p><h3 id="1-2-1-类型推导中的类型转换"><a href="#1-2-1-类型推导中的类型转换" class="headerlink" title="1.2.1 类型推导中的类型转换"></a>1.2.1 类型推导中的类型转换</h3><p>在类型推导的时候自动的类型转换是受限制的：</p><ul><li>如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的两个参数，它们实参的类型必须完全一样。</li><li>如果调用参数是按值传递的，那么只有<strong>退化(decay)</strong>这一类简单转换是被允许的：<code>const</code> 和 <code>volatile</code> 限制符会被忽略，引用被转换成被引用的类型，<strong>数组(raw array)</strong>和函数被转换为相应的指针类型。通过模板类型参数 T 定义的两个参数，它们实参的类型在退化后必须一样。</li></ul><p>例如：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>;...<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> c = <span class="hljs-number">42</span>;max(i, c); <span class="hljs-comment">// OK: T 被推导为 int</span>max(c, c); <span class="hljs-comment">// OK: T 被推导为 int</span><span class="hljs-keyword">int</span>&amp; ir = i;max(i, ir); <span class="hljs-comment">// OK: T 被推导为 int</span><span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>];max(&amp;i, arr); <span class="hljs-comment">// OK: T 被推导为 int*</span></code></pre><p>但是像下面这样是错误的：</p><pre><code class="hljs c++"><span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// ERROR: 不确定 T 该被推导为 int 还是 double</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<span class="hljs-built_in">max</span>(<span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">//ERROR: 不确定 T 该被推导为 const[6] 还是 std::string</span></code></pre><p>有三种办法解决以上错误：</p><ol><li><p>对参数进行类型转换，使参数同时匹配。</p><pre><code class="hljs c++"><span class="hljs-built_in">max</span>(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>), <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK</span></code></pre></li><li><p>显示地指出T的类型取阻止编译器进行类型推导。</p><pre><code class="hljs c++"><span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK</span></code></pre></li><li><p>指明参数可能有多个不同的类型（使用多个模板参数）。</p></li></ol><h3 id="1-2-2-对默认参数的类型推导"><a href="#1-2-2-对默认参数的类型推导" class="headerlink" title="1.2.2 对默认参数的类型推导"></a>1.2.2 对默认参数的类型推导</h3><p>需要注意的是，类型推导并不适用于默认参数。例如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T = <span class="hljs-string">""</span>)</span></span>;...f(<span class="hljs-number">1</span>); <span class="hljs-comment">// OK: T 被推导为 int，调用 f&lt;int&gt; (1)</span>f(); <span class="hljs-comment">// ERROR: 无法推导 T 的类型</span></code></pre><p>为应对这一情况，你需要给模板类型参数也声明一个默认参数</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;<span class="hljs-keyword">void</span> f(T = <span class="hljs-string">""</span>);...f(); <span class="hljs-comment">// OK</span></code></pre><h2 id="1-3-多模板参数"><a href="#1-3-多模板参数" class="headerlink" title="1.3. 多模板参数"></a>1.3. 多模板参数</h2><p>目前我们看到与函数模板有关的两组参数：</p><ol><li><p><strong>模板参数(template parameters)</strong>，定义在函数模板前的尖括号中：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// T 是模板参数</span></code></pre></li><li><p><strong>调用参数(call parameters)</strong>，定义在函数模板名称后的圆括号中：</p><pre><code class="hljs c++"><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> <span class="hljs-comment">// a 和 b 是调用参数</span></span></code></pre></li></ol><p>模板参数可以是一个或者多个。比如，你可以定义这样一个 <code>max()</code> 模板，它可能接受两个不同类型的调用参数：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function">T1 <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;...<span class="hljs-keyword">auto</span> m = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK, 但是返回类型是第一个模板参数 T1 的类型</span></code></pre><p>看上去如你所愿，它是可以接受两个不同类型的调用参数。但是，这也导致了一个问题。如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地一样，当应该返回另一个类型的值的时候，返回值会被做类型转换。这将导致返回值的具体类型和参数的传递顺序有关。如果传递 <code>66.66</code> 和 <code>42</code> 给这个函数模板，返回值是 <code>double</code> 类型的 <code>66.66</code>，但是如果传递 <code>42</code> 和 <code>66.66</code>，返回值却是 <code>int</code> 类型的 <code>66</code>。</p><p>C++提供了多种方法来解决这一问题：</p><ol><li>引入第三个模板参数作为返回类型。</li><li>让编译器找出返回类型</li><li>将返回类型定义为两个参数类型的<strong>公共类型(common type)</strong>。</li></ol><h3 id="1-3-1-返回类型的模板参数"><a href="#1-3-1-返回类型的模板参数" class="headerlink" title="1.3.1 返回类型的模板参数"></a>1.3.1 返回类型的模板参数</h3><p>我们可以像调用普通函数一样条用函数模板，也可以显式地指出模板参数的参数类型。</p><p>当模板参数和调用参数直接没有必然联系，且模板参数不能确定是，就要显式地指明模板参数。例如，你可以引入第三个模板参数来指定函数模板的返回类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> RT&gt;<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;</code></pre><p>但是模板类型推导不会考虑返回类型，而 <code>RT</code> 不是函数的调用参数的类型。因此 <code>RT</code> 不会被推导。这样就必须显式的指明模板参数的类型。比如：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> RT&gt;<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;...::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">double</span>,<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// OK, 但是太繁琐</span></code></pre><p>到目前为止，我们看到的情况是，要么所有模板参数都被显式指定，要么一个都不指定。另一种办法是只指定第一个模板参数的类型，其余参数的类型通过推导获得。通常而言，我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推导出来为止。因此，如果你改变了上面例子中的模板参数顺序，调用时只需要指定返回值的类型就可以了：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span>;...::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>) <span class="hljs-comment">//OK: 返回类型是 double，T1 和 T2 根据调用参数推导</span></code></pre><p>在本例中，调用 <code>max&lt;double&gt;</code> 时，显式的指明了 <code>RT</code> 的类型是 <code>double</code>，<code>T1</code> 和 <code>T2</code> 则基于传入调用参数的类型被推导为 <code>int</code> 和 <code>double</code>。<br>然而改进版的 <code>max()</code> 并没有带来显著的变化。使用单模板参数的版本，即使传入的两个调用参数的类型不同，你依然可以显式的指定模板参数类型（也作为返回类型）。因此为了简洁，我们最好还是使用单模板参数的版本。</p><h3 id="1-3-2-推导返回类型"><a href="#1-3-2-推导返回类型" class="headerlink" title="1.3.2 推导返回类型"></a>1.3.2 推导返回类型</h3><p>如果返回类型是由模板参数决定的，那么推导返回类型最简单也是<strong>最好的</strong>办法就是让编译器来做这件事。C++14 开始，这成为可能，而且不需要把返回类型声明为任何模板参数类型（不过你需要声明返回类型为 <code>auto</code>）：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>在 C++14 之前，要想让编译器推导出返回类型，就必须让或多或少的函数实现成为函数声明的一部分。在 C++11 中，<strong>尾置返回类型(trailing return type)</strong>允许我们使用函数的调用参数。也就是说，我们可以基于运算符 <code>?:</code> 的结果声明返回类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>在这里，返回类型是由运算符<code>?:</code>的结果决定的，这虽然复杂但是可以得到想要的结果。</p><p>需要注意的是</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b);</code></pre><p>是一个声明，编译器在编译阶段会根据  <code>?:</code>  调用参数 <code>a</code> 和 <code>b</code> 的返回结果来决定实际的返回类型。不过具体实现时不一定需要匹配。所以事实上只要使用 <code>true</code> 作为运算符 <code>?:</code> 的条件就行了：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;auto max(T1 a, T2 b) -&gt; decltype(true ? a : b);</code></pre><p>但是在某些情况下会有一个严重的问题：由于 <code>T</code> 可能是引用类型，返回类型就也可能被推导为引用类型。因此你应该返回的是<strong>退化(decay)</strong>后的 <code>T</code>，像下面这样：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>这里用到了 <em>type trait</em> <code>std::decay&lt;&gt;</code>，它的 <code>type</code> 成员返回目标类型，它定义在标准库 <code>&lt;type_traits&gt;</code> 中。因为其 <code>type</code> 成员是结果类型，为了获取其结果，应该用关键字 <code>typename</code> 来修饰这个表达式。</p><p>注意，在初始化 <code>auto</code> 类型是总是<strong>退化(decay)</strong>后的类型。它同样支持返回类型是 <code>auto</code>。 用 <code>auto</code> 作为返回结果的效果就像下面那样，<code>a</code> 的类型被推导为 <code>i</code> 退化后的类型，即为 <code>int</code>：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span>&amp; ir = i; <span class="hljs-comment">// ir 是 i 的引用</span><span class="hljs-keyword">auto</span> a = ir; <span class="hljs-comment">// a 的类型是 ir decay 之后的类型，也就是int</span></code></pre><h3 id="1-3-3-作为通用类型返回"><a href="#1-3-3-作为通用类型返回" class="headerlink" title="1.3.3 作为通用类型返回"></a>1.3.3 作为通用类型返回</h3><p>从C++11 开始，标准库提供了一种指定“更一般类型”的方式。<code>std::common_type&lt;&gt;::type</code> 产生的类型是他的两个（或更多）模板参数的公共类型。比如：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;std::common_type_t&lt;T1, T2&gt; max(T1 a, T2 b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>同样的，<code>std::common_type&lt;&gt;</code> 也是一个 <em>type trait</em>，定义在标准库 <code>type_traits</code> 中，它返回一个结构体，其 <code>type</code> 成员是结果类型。其主要的应用如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::common_type&lt;T1, T2&gt;::type <span class="hljs-comment">//since C++11</span></code></pre><p>在C++14后，你可以简化其用法，仅需在后面加一个 <code>_t</code>，就可以省掉 <code>typename</code> 和 <code>::type</code>，简化后的版本变为：</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">common_type_t</span>&lt;T1, T2&gt; <span class="hljs-comment">// equivalent since C++14</span></code></pre><p><code>std::common_type&lt;&gt;</code> 的实现用到了一些比较取巧的模板编程手法（后续会介绍）。它根据运算符 <code>?:</code> 的语法规则或者对某些类型的特化来决定目标类型。因此 <code>::max(4, 7.2)</code> 和 <code>::max(7.2, 4)</code> 都返回 <code>double</code> 类型的 <code>7.2</code>。需要注意的是，<code>std::common_type&lt;&gt;</code>的结果也是<strong>退化(decay)</strong>的。</p><h2 id="1-4-缺省模板参数-Default-Template-Arguments"><a href="#1-4-缺省模板参数-Default-Template-Arguments" class="headerlink" title="1.4. 缺省模板参数(Default Template Arguments)"></a>1.4. 缺省模板参数(Default Template Arguments)</h2><p>你也可以给函数模板参数指定一个默认值。这些默认值被称为<strong>缺省模板参数(default template arguments)</strong>【也称为默认模板参数】并且可以用在任何类型的模板中。它们甚至可以通过前面的模板参数来决定自己的类型。</p><p>例如，如果你想像前面叙述的那样是返回类型有多个模板参数，你可以定义一个模板参数 <code>RT</code>，并将其默认类型声明为其他两个模板的公共类型。同样的我们也有多种实现方法：</p><ol><li><p>可以直接使用 <code>?:</code> 运算符。不过由于我们必须在<strong>调用参数(call parameters)</strong> <code>a</code> 和 <code>b</code> 被声明之前使用运算符 <code>?:</code>，我们只能用它们的类型：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2,<span class="hljs-keyword">typename</span> RT =           <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-literal">true</span> ? T1() : T2())&gt;&gt;RT <span class="hljs-built_in">max</span>(T1 a, T2 b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>请注意我们使用了 <code>std::decay_t&lt;&gt;</code> 来确保返回的类型不是引用类型。</p><p>同样值得注意的是，这一实现方法要求我们能够调用两个模板参数的<strong>默认构造(default constructor)</strong>。还有另一种方法，使用 <code>std::declval</code>，不过这将使得声明部分更加复杂，以后我们会讲到。</p></li><li><p>我们同样可以使用 <em>type trait</em> <code>std::decay_t&lt;&gt;</code> 作为返回类型的默认值：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2,          <span class="hljs-keyword">typename</span> RT = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">common_type_t</span>&lt;T1, T2&gt;&gt;RT <span class="hljs-built_in">max</span>(T1 a, T2 b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>在这里<code>std::common_type_t&lt;&gt;</code> 也是会做退化的，因此返回类型不会是引用。</p></li></ol><p>在以上两种情况下，你可以使用 <code>RT</code> 的默认值作为返回类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>);</code></pre><p>也可以显式地指出所有的函数模板参数的类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> b = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7.2</span>, <span class="hljs-number">4</span>);</code></pre><p>但是，我们再次遇到这样一个问题：为了显式指出返回类型，我们必须显式的指出全部三个模板参数的类型。因此我们希望能够将返回类型作为第一个模板参数，并且依然能够从其它两个模板参数推断出它的类型。</p><p>原则上这是可行的，即使后面的模板参数没有默认值，我们依然可以让第一个模板参数有默认值：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT = <span class="hljs-keyword">long</span>, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;RT <span class="hljs-built_in">max</span>(T1 a, T2 b)&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>基于这个定义，你可以这样调用：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">long</span> l;...<span class="hljs-built_in">max</span>(i, l);     <span class="hljs-comment">// 返回值类型是long (RT 的默认值)</span><span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">//返回int，因为其被显式指定</span></code></pre><p>但是只有当模板参数具有一个“天生的”默认值时，这才有意义。我们真正想要的是从前面的模板参数推导出想要的默认值。原则是这也是可行的（后续会讨论到），但是他是基于类型萃取的，并且会使定义变得更加复杂。</p><p>基于以上原因，最好也是最简单的办法就是像<a href="#推导返回类型">前面讨论的那样</a>让编译器来推断出返回类型。</p><h2 id="1-5-重载函数模板"><a href="#1-5-重载函数模板" class="headerlink" title="1.5. 重载函数模板"></a>1.5. 重载函数模板</h2><p>像普通函数一样，模板也是可以重载的。也就是说，你可以定义多个有相同函数名的函数，当实际调用的时候，由C++编译器负责决定具体该调用哪一个函数。</p><p>下列程序展示了函数模板的重载：</p><pre><code class="hljs c++"><span class="hljs-comment">// maximum of two int values:</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125; <span class="hljs-comment">// maximum of two values of any type:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);         <span class="hljs-comment">// 调用非模板函数</span>    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7.0</span>, <span class="hljs-number">42.0</span>);     <span class="hljs-comment">// 调用 max&lt;double&gt; (通过类型推导)</span>    ::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);      <span class="hljs-comment">//调用 max&lt;char&gt; (通过类型推导)</span>    ::<span class="hljs-built_in">max</span>&lt;&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);       <span class="hljs-comment">// 调用 max&lt;int&gt; (通过类型推导)</span>    ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// 调用 max&lt;double&gt; (无类型推导)</span>    ::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">42.7</span>);     <span class="hljs-comment">//调用非模板函数</span>&#125;</code></pre><p>这个例子展示了一个非模板函数可以与其同名的函数模板共存，并且这个函数模板可以被实例化与非模板函数具有相同类型的调用函数。在其他因素相同时，模板解析过程<strong>优先选择</strong>非模板函数，而不是模板实例化出来的函数。第一个调用就属于这种情况：</p><pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">//两个 int 变量都完美匹配了非模板函数</span></code></pre><p>如果模板可以实例化出一个更匹配的函数，那么就会选择这个模板。如第二和第三次调用 <code>max()</code> 时：</p><pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-number">7.0</span>, <span class="hljs-number">42.0</span>);     <span class="hljs-comment">// 调用 max&lt;double&gt; (通过类型推导)</span>::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);      <span class="hljs-comment">//调用 max&lt;char&gt; (通过类型推导)</span></code></pre><p>在此模板更加匹配，因为它不需要把 <code>double</code> 和 <code>char</code> 转换为 <code>int</code>。</p><p>也可以显式指定一个空的模板列表。这表明它会被解析成一个模板调用，其所有的模板参数会被通过调用参数推断出来：</p><pre><code class="hljs c++">::<span class="hljs-built_in">max</span>&lt;&gt;(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>);       <span class="hljs-comment">// 调用 max&lt;int&gt; (通过类型推导)</span></code></pre><p>由于在模板参数推断时<strong>不允许</strong>自动类型转换，而常规函数是允许的，因此最后一个调用会选择非模板参函数（ <code>a</code> 和 <code>42.7</code> 都被转换成 <code>int</code>）：</p><pre><code class="hljs c++">::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">42.7</span>);     <span class="hljs-comment">//只有非模板函数允许 nontrivial conversion</span></code></pre><p>一个有趣的例子是我们可以专门为 <code>max()</code> 显示指定其返回值类型的模板来进行重载：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RT, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function">RT <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>现在我们可以向这样调用 <code>max()</code>:</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">// 调用第一个函数模板</span><span class="hljs-keyword">auto</span> b = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">7.2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 调用用第二个函数模板</span></code></pre><p>但是想下面这样调用的话：</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> c = ::<span class="hljs-built_in">max</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">7.2</span>); <span class="hljs-comment">//ERROR: 两个函数模板同时匹配</span></code></pre><p>两个模板都是匹配的，这会导致模板解析过程不知道该调用哪一个模板，从而导致未知错误。因此当重载函数模板的时候，要保证对任意一个调用，都只会有一个模板匹配。</p><p>一个比较有用的例子是为指针和 <code>C-strings</code> 重载 <code>max()</code> 模板：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-comment">// maximum of two values of any type:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-comment">// maximum of two pointers:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T *<span class="hljs-title">max</span><span class="hljs-params">(T *a, T *b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> *b &lt; *a ? a : b;&#125;<span class="hljs-comment">// maximum of two C -strings :</span><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *a, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strcmp</span>(b, a) &lt; <span class="hljs-number">0</span> ? a : b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">42</span>;    <span class="hljs-keyword">auto</span> m1 = ::<span class="hljs-built_in">max</span>(a, b); <span class="hljs-comment">// max() for two values of type int</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"hey"</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"you"</span>;    <span class="hljs-keyword">auto</span> m2 = ::<span class="hljs-built_in">max</span>(s1, s2); <span class="hljs-comment">// max() for two values of type std::string</span>        <span class="hljs-keyword">int</span> *p1 = &amp;b;    <span class="hljs-keyword">int</span> *p2 = &amp;a;    <span class="hljs-keyword">auto</span> m3 = ::<span class="hljs-built_in">max</span>(p1, p2); <span class="hljs-comment">// max() for two pointers</span>    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *x = <span class="hljs-string">"hello"</span>;    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *y = <span class="hljs-string">"world"</span>;    <span class="hljs-keyword">auto</span> m4 = ::<span class="hljs-built_in">max</span>(x, y); <span class="hljs-comment">// max() for two C-strings</span>&#125;</code></pre><p>注意上面所有 <code>max()</code> 的重载模板中，调用参数都是按<strong>值</strong>传递的。通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。否则，可能会遇到意想不到的问题。比如，如果你实现了一个按引用传递的 <code>max()</code> 模板，然后又重载了一个按值传递两个 C 字符串作为参数的模板，你不能用接受三个参数的模板来计算三个 C 字符串的最大值：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-comment">// maximum of two values of any type (call-by-reference)</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;a, T <span class="hljs-keyword">const</span> &amp;b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-comment">// maximum of two C-strings (call-by-value)</span><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *<span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *a, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strcmp</span>(b, a) &lt; <span class="hljs-number">0</span> ? a : b;&#125;<span class="hljs-comment">// maximum of three values of any type (call-by-reference)</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;a, T <span class="hljs-keyword">const</span> &amp;b, T <span class="hljs-keyword">const</span> &amp;c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c); <span class="hljs-comment">// error if max(a,b) uses call-by-value</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">auto</span> m1 = ::<span class="hljs-built_in">max</span>(<span class="hljs-number">7</span>, <span class="hljs-number">42</span>, <span class="hljs-number">68</span>); <span class="hljs-comment">// OK</span>        <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s1 = <span class="hljs-string">"frederic"</span>;    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s2 = <span class="hljs-string">"anica"</span>;    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *s3 = <span class="hljs-string">"lucas"</span>;    <span class="hljs-keyword">auto</span> m2 = ::<span class="hljs-built_in">max</span>(s1, s2, s3); <span class="hljs-comment">//run-time ERROR</span>&#125;</code></pre><p>问题在于当用三个 C 字符串作为参数调用 <code>max()</code> 的时候，</p><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c);</code></pre><p>会遇到run-time error，这是因为对C 字符串，<code>max(max(a, b), c)</code> 会创建一个用于返回的临时局部变量，而在返回语句接受后，这个临时变量会被销毁，导致 <code>max()</code> 使用了一个悬空的引用。不幸的是，这个错误几乎在所有情况下都不太容易被发现。</p><p>作为对比，在求三个 <code>int</code> 最大值的 <code>max()</code> 调用中，则不会遇到这个问题。这里虽然也会创建三个临时变量，但是这三个临时变量创建在 <code>main()</code> 中，它们的存在时间会持续到语句结束。</p><p>这只是模板解析与期望结果不一致的一个例子。另外，要确保函数模板在调用前已经被定义。这是由于我们调用某个函数模板时，不是所有的重载函数都是可见的。比如我们定义了三个参数的 <code>max()</code> 函数，由于它调用适用于两个 <code>int</code> 类型的 <code>max()</code> 时，重载的两个 <code>int</code> 类型的 <code>max()</code> 是不可见的，因此它最终会调用两个参数的模板函数：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// maximum of two values of any type:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max&lt;T&gt;() \n"</span>;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125; <span class="hljs-comment">// maximum of three values of any type:</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b, T c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a, b), c); <span class="hljs-comment">//仍然使用函数模板</span>   <span class="hljs-comment">//因为重载的声明在后面</span>&#125;<span class="hljs-comment">// maximum of two int values:</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"max(int,int) \n"</span>;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ::<span class="hljs-built_in">max</span>(<span class="hljs-number">47</span>, <span class="hljs-number">11</span>, <span class="hljs-number">33</span>);     <span class="hljs-comment">// OOPS: uses max&lt;T&gt;() instead of max(int,int)</span>&#125;</code></pre><h2 id="1-6-但是，不应该使用？"><a href="#1-6-但是，不应该使用？" class="headerlink" title="1.6. 但是，不应该使用？"></a>1.6. 但是，不应该使用？</h2><h3 id="1-6-1-按值传递还是按应用传递？"><a href="#1-6-1-按值传递还是按应用传递？" class="headerlink" title="1.6.1 按值传递还是按应用传递？"></a>1.6.1 按值传递还是按应用传递？</h3><p>我们声明的函数通常都是按值传递，而不是按引用传递。通常而言，建议将按引用传递除简单类型（比如<strong>基础类型(fundamental type)</strong>和 <code>std::string_view</code>）以外的类型，这样可以免除不必要的拷贝成本。</p><p>但是出于以下原因，<strong>按值传递</strong>通常更好一些：</p><ul><li>语法简单。</li><li>编译器优化更好。</li><li>移动语意是的拷贝成本较低。</li><li>某些情况下没有拷贝或者移动。</li></ul><p>再有，对于模板，还有一些特殊情况：</p><ul><li>模板可能用于简单类型也可能由于复杂类型，因此如果选择利于复杂类型的方式，可能会对简单类型产生不利的影响。</li><li>作为调用者，你可以通过使用 <code>std::ref()</code> 和 <code>std::cref()</code> 决定是否按照引用传递参数。</li><li>尽管传递 <em>string literal</em> 和 <em>raw array</em> 会产生一些问题，按时如果按照引用传递它们会产生更大的问题。</li></ul><p>后续会对此进行进一步讨论，<strong>除了某些不得不用按引用传递的情况，尽量使用按值传递。</strong></p><h3 id="1-6-2-为什么不用-inline？"><a href="#1-6-2-为什么不用-inline？" class="headerlink" title="1.6.2 为什么不用 inline？"></a>1.6.2 为什么不用 inline？</h3><p>通常，函数模板不需要声明为 <code>inline</code>。不像普通的 <code>noninline</code> 函数，我们可以把 <code>noninline</code> 函数模板定义在同文件中，然后再多个编译单元里 <code>include</code> 这个头文件。</p><p>唯一一个例外是模板对某些类型进行了<strong>全特化(full spcializations)</strong>，这时的结果代码不再是<strong>泛型(generic)</strong>的(所有的模板参数都已经被指定了)。后续会详细讨论。</p><p>严格地从语言角度来看，<code>inline</code> 只意味着在程序中函数的定义可以出现很多次。不过它也给了编译器一个暗示，在调用该函数的地方函数应该被展开成 <code>inline</code> 的：这样做在某些情况下可以提高效率，但是在另一些情况下也可能降低效率。现代编译器在没有关键字 <code>inline</code> 暗示的情况下，通常也可以很好的决定是否将函数展开成 <code>inline</code> 的。当然，编译器在做决定的时候依然会将关键字 <code>inline</code> 纳入考虑因素。</p><h3 id="1-6-3-为什么不用-constexpr？"><a href="#1-6-3-为什么不用-constexpr？" class="headerlink" title="1.6.3 为什么不用 constexpr？"></a>1.6.3 为什么不用 constexpr？</h3><p>从 C++11 开始，你可以通过关键字 <code>constexpr</code> 来在编译期进行某些运算。对于很多模板来说，这是有意义的。</p><p>比如为了可以在编译期使用求最大值的函数，你需要将函数模板定义如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> b &lt; a ? a : b;&#125;</code></pre><p>通过此，你可以使用此函数在编译期就求出最大值，例如当定义数列的大小时：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">1000u</span>)];</code></pre><p>或者指定 <code>std::array&lt;&gt;</code> 的大小：</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, ::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), 1000u)&gt; arr;</code></pre><p>在这里我们传递的 1000 是 <code>unsigned int</code> 类型，这样可以避免直接比较一个有符号数值和一个无符号数值时产生的警报。</p><p>后续也会继续讨论 <code>constexpr</code>。</p><h2 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7. 小结"></a>1.7. 小结</h2><ul><li>函数模板定义了一组适用于不同类型的函数</li><li>当向模板函数传递变量时，函数模板会自行推导模板参数的类型，来决定去实例化出那种类型的函数。</li><li>你也可以显式的指出模板参数的类型。</li><li>你可以定义模板参数的默认值。这个默认值可以使用该模板参数前面的模板参数的类型，而且其后面的模板参数可以没有默认值。</li><li>函数模板可以被重载。</li><li>当定义新的函数模板来重载已有的函数模板时，必须要确保在任何调用情况下都只有一个模板是最匹配的。</li><li>当你重载函数模板的时候，最好只是显式地指出了模板参数的类型。</li><li>确保在调用某个函数模板之前，编译器已经看到了相对应的模板定义。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Template</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-2.1 信息表示和处理-信息储存</title>
    <link href="/2020/07/07/CSAPP_2_1/"/>
    <url>/2020/07/07/CSAPP_2_1/</url>
    
    <content type="html"><![CDATA[<p>简述了计算机信息的储存方式、十六进制表示法，布尔代数和C语言中的位运算、逻辑运算和移位操作三类运算符。</p><a id="more"></a><h2 id="2-1-信息储存"><a href="#2-1-信息储存" class="headerlink" title="2.1 信息储存"></a>2.1 信息储存</h2><p>​        大多数计算机使用8位的块，或者<strong>字节(byte)</strong>，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级的程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存(virtual memory)</strong>。内存的每个字节都由一个唯一的数字来标识，称为它的<strong>地址(address)</strong>，所有可能的地址的集合就称为<strong>虚拟地址空间(virtual address space)。</strong>虚拟地址空间只是一个展现给机器级程序的概念性映像，实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。</p><h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>​        一个字节有8位组成。在二进制表示法中，它的值域是$00000000_2\sim 11111111_2$。如果看成十进制整数，它的值域就是$0_{10}\sim255_{10}$。两种符合表示法对于表述位模式都不是很方便所以引入了<strong>十六进制(hexadecimal)</strong>表示法。用十六进制书写，一个字节的值域为$00_{16}\sim FF_{16}$。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-2-1/1.png" srcset="/img/loading.gif" alt="十六进制表示法"></p><p>​        在C语言中，以 <code>0x</code>或 <code>0X</code>开头的数字常量为被认为是十六进制的值。</p><h3 id="字数据的大小"><a href="#字数据的大小" class="headerlink" title="字数据的大小"></a>字数据的大小</h3><p>​        每台计算机都有一个<strong>字长(word size)</strong>，指明指针数据的标称大小(nominal size)。因为，虚拟地址是以这样的一个字节来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 $w$位对的机器而言，虚拟地址的范围为$0$~$2^w-1$，程序最多访问$2^w$个字节。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-2-1/2.png" srcset="/img/loading.gif" alt="基本C数据类型的典型大小"></p><h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>​        对于跨越多字节的程序对象，我们必须建立两个原则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。</p><p>​        排列表示一个对象的字节有两个通用的规则。考虑一个$w$位的整数，其位表示为$[x_{w-1},x_{w-2},···，x_1,x_0]$，其中$x_{w-1}$是最高有效位，而$x_0$是最低有效位。假设$w$是8的倍数，这些为就能被分组成为字节，其中最高有效字节包含位$[x_{w-1},x_{w-2},···,x_{w-8}]$，而最低有效字节包含位$[x_7,x_6,x_5,x_4,x_3,x_2,x_1,x_0]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节的顺序储存。前一种规则——最低有效字节在最前面的方式，称为<strong>小端法(little endian)</strong>。后一种规则——最高有效字节在最前面的方式，称为<strong>大端法(big endian)</strong>。</p><p>​        假设变量 x的类型为 <code>int</code>，位于地址 <code>0x100</code>处，它的十六进制值为 <code>0x01234567</code>。地址范围<code>0x100</code>~<code>0x103</code>的字节顺序依赖于机器的类型：</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-2-1/3.png" srcset="/img/loading.gif" alt="大端法和小端法"></p><p>​        对于大多数应用程序员来说，其机器所使用的的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据是，一个常见的问题是当小端法机器及其产生的数据被发送到大端法机器（或者反过来），接受程序会发现，字里的字节成了反序的，为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换为网络标准，而接收方则将网络标准转换为它的内部表示。</p><p>第二种情况是，当阅读表示证书数据的字节序列是字节顺序也很重要。</p><p>第三种情况是，当编写规避正常的类型的程序时，字节顺序很重要。在C语言中，可以通过<strong>强制类型转换(cast)</strong>或<strong>联合(union)</strong>来允许以一种数据类型引用对象，而这种数据类型与创建这个对象是定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是他们对系统级编程来说是非常有用，甚至是必需的。</p><h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>​        C语言中字符串被编码为一个以<code>null</code>（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符吗。字符串在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。</p><h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><p>​        不同的及其类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p><p>​        计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始程序的任何信息，除了可能有些用来帮助调试的辅助表以外。</p><h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><p>​        二进制是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经演化出了丰富的数学知识体系。</p><p>​        最简单的布尔代数实在二元集合${0,1}$基础上的定义，布尔运算  $\sim$ 对应于逻辑运算 NOT，在命题逻辑中用符号 $\neg$ 表示。也就是说，$P$ 不为真时，$\neg P$ 为真，反之亦然。 相应地， 当 $P$ 等于0时，$\sim P$ 等于 1，反之亦然。布尔运算 $\&amp;$ 对应于逻辑运算 AND， 在命题逻辑中用符号 $\wedge$ 表示。当 $P$ 和 $Q$ 都为真时，我们说 $P\wedge Q$ 为真。相应的，只有当 $p=1$ 且 $q=1$ 时，$p\&amp; q$ 才等于1。布尔运算 $|$ 对应与逻辑运算 OR， 在命题逻辑中用符号 $\vee$ 表示。 当 $P$ 或者 $Q$ 为真时，我们说 $ P\vee Q$ 成立。相应地，当 $p=1$ 或者 $q=1$ 时，$p| q$ 等于1。布尔运算 $\hat{}$ 对应逻辑运算异或，在命题逻辑中用符号 $\oplus$ 表示。 当 $P$ 或者 $Q$ 为真但不同时为真时，我们说 $ P\oplus Q$ 成立。当 $p=1$ 且 $q=0$，或者 $p=0$ 且 $q=1$， $p\hat{} q$ 等于1。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-2-1/4.png" srcset="/img/loading.gif" alt="布尔代数的运算"></p><p>我们可以将上述4个布尔运算扩展到<strong>位向量</strong>的运算，位向量就是固定长度为$w$、由0和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。假设 $a$ 和 $b$ 分别表示位向量 $[a_{w-1},a_{w-2},···,a_0]$ 和 $[b_{w-1},b_{w-2},···,b_0]$。 我们将 $a\&amp;b$ 也定义为一个长度为 $w$ 的位向量，其中第 $i$ 个元素等于 $a_i\&amp; b_i$，$0\leqslant i &lt; w$。可以用类似的方式将运算 $|$ 、$\hat{}$ 和 $\sim$ 拓展到位运算上。</p><p>位向量是一个很有用的应有就是表示有限集合。我们可以用位向量 $[a_{w-1},a_{w-2},···,a_0]$ 编码任何子集 $A\subseteq {0,1,···,w-1 }$，其中 $a_i = 1$ 当且仅当 $i\in{A}$。</p><h3 id="C语言中的位级运算"><a href="#C语言中的位级运算" class="headerlink" title="C语言中的位级运算"></a>C语言中的位级运算</h3><p>​        C语言的布尔运算符号：<code>|</code> OR（或），<code>&amp;</code>  AND（与），<code>~</code> NOT（取反），<code>^</code> EXCLUSIVE-OR（异或）。</p><h3 id="C语言中的逻辑运算"><a href="#C语言中的逻辑运算" class="headerlink" title="C语言中的逻辑运算"></a>C语言中的逻辑运算</h3><p>​        C语言的逻辑运算符号<code>||</code>、<code>&amp;&amp;</code>、<code>!</code>，分别对应命题逻辑中的OR、AND 和 NOT。</p><h3 id="C语言中的移位操作"><a href="#C语言中的移位操作" class="headerlink" title="C语言中的移位操作"></a>C语言中的移位操作</h3><p>​        C语言提供了一组移位运算符<code>&lt;&lt;</code>、<code>&gt;&gt;</code>，向左或者向右移位模式。对于左移<code>x &lt;&lt; k</code>来说，x 向左移动 $k$ 位，并在右端补 $k$ 个 0。对于右移<code>x &gt;&gt; k</code>来说，机器支持两种形式的右移：<strong>逻辑右移</strong>和<strong>算术右移</strong>。逻辑右移就是在左端补 $k$ 个 0。算术右移是在左端补 $k$ 个最高有效位的值。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Virtual Function</title>
    <link href="/2020/07/07/cpp_virtual_function/"/>
    <url>/2020/07/07/cpp_virtual_function/</url>
    
    <content type="html"><![CDATA[<p>简单介绍了C++虚函数的基本概念和用法及其底层的实现原理</p><a id="more"></a><h1 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a>C++虚函数</h1><h2 id="基本概念与用法"><a href="#基本概念与用法" class="headerlink" title="基本概念与用法"></a>基本概念与用法</h2><p>虚函数是应在派生类中重新定义的成员函数。 当使用<strong>指针</strong>或对<strong>基类的引用</strong>来引用派生的类对象时，可以为该对象调用虚函数并执行该函数的派生类版本。虚函数是动态绑定的，所以<strong>不能</strong>将静态函数声明为虚函数。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span><span class="hljs-comment">//nonvirtual function</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in A::foo1"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span><span class="hljs-comment">//define a virtual function</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in A::foo2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span> <span class="hljs-keyword">public</span> A&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span><span class="hljs-comment">//nonvirtual function</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in B::foo1"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span>  <span class="hljs-comment">//virtual function</span></span><span class="hljs-function"><span class="hljs-comment">//virtual is optional explanation     </span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in B::foo2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A&amp; a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in func: "</span>;    a.foo2();<span class="hljs-comment">//call virtual function</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    A* b = <span class="hljs-keyword">new</span> B();    b-&gt;foo1();<span class="hljs-comment">//call nonvirtual function</span>    b-&gt;foo2();<span class="hljs-comment">//call virtual function</span>&#125;</code></pre><p>基类的虚函数必须定义，除非被声明为纯虚函数，即基类为抽象类。</p><p>基类当定义好后虚函数后，则在基类所有的派生类中，此函数都是虚函数，若没有被重载就会默认使用该派生类父类所重载的虚函数。</p><p>若要重载该虚函数，可以显式地使用<code>virtual</code>关键词（但不必要）来重载此虚函数。</p><p>派生类的虚函数的返回类型，参数列表需要同基类的虚函数相同，但也有例外情况，若基类返回的是类本身的指针或引用时，上述规则无效。</p><h3 id="final-与-override"><a href="#final-与-override" class="headerlink" title="final 与 override"></a>final 与 override</h3><p>C++11后，新增了两个后缀说明符<code>final</code>和<code>override</code>, <code>override</code>是可选的，用来显式说明该虚函数是被重载的，而<code>final</code>用来说明该类的虚函数不能被其派生类重载。</p><h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>若想指定地执行虚函数的某个版本，可以使用作用域运算符来实现，例如</p><pre><code class="hljs cpp">A* test = <span class="hljs-keyword">new</span> B();test-&gt;foo2();<span class="hljs-comment">//call B::foo2()</span>test-&gt;A::foo2(); <span class="hljs-comment">//call A::foo2()</span></code></pre><p>注：此调用是在编译时刻完成的。</p><h2 id="虚函数的实现"><a href="#虚函数的实现" class="headerlink" title="虚函数的实现"></a>虚函数的实现</h2><ol><li><p>每一个class产生出一堆指向virtual function 的指针，放在表格之中。这个表格被称为virtual table (<strong>vtbl</strong>)。</p></li><li><p>每一个class object 被安插了一个指针，指向相关的virtual table。通常这个指针被称为<strong>vptr</strong>。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/cover/cpp_virtual_function.jpg" srcset="/img/loading.gif" alt="未命名文件"></p></li></ol><p>在用派生类初始化基类的引用和指针时，编译器仅会修改指针的类型（即指针所指的内存的大小和其内容），但不会修改类中的<strong>vptr</strong>，所以类中的<strong>vptr</strong>指向的还是派生类的<strong>vtbl</strong>。注意指针所涵盖的地址只包含派生类中的派生于基类的成员，你不能通过其访问派生类特有的成员，但是你可以通过调用virtual function来访问派生类特有的成员。</p><p>在使用基类构造函数转化派生类时，会将<strong>vptr</strong>重新设定为基类的<strong>vptr</strong>，并不会沿用派生类的<strong>vptr</strong>，并对派生类的成员进行<strong>截断</strong>，只保留基类的成员，此时不会展现多态性。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-1 计算机系统漫游</title>
    <link href="/2020/07/06/CSAPP_1/"/>
    <url>/2020/07/06/CSAPP_1/</url>
    
    <content type="html"><![CDATA[<p>简单介绍了计算机系统的组成，存储层次结构，操作系统内核及其抽象的知识。</p><a id="more"></a><h2 id="1-计算机系统漫游"><a href="#1-计算机系统漫游" class="headerlink" title="1. 计算机系统漫游"></a>1. 计算机系统漫游</h2><h3 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/1.png" srcset="/img/loading.gif" alt="一个典型系统的硬件组成"></p><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>​        贯穿整个系统的是一组电子管道，成为<strong>总线</strong>，它携带信息字节并负责在各个部件间触底。通常总线被设计成传送定长的字节块，也就是<strong>字(word)</strong>。自重的字节是(即字长)是一个系统参数，各个系统都不尽相同。</p><h4 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h4><p>​        I/O(输入/输出)设备是系统与外部世界的联系通道。每个I/O设备都通过一个控制器或适配器与I/O总线连接。控制器和适配器的区别主要在它们的封装方式。控制器是I/O设备本身或者系统主印制电路板(通常称作<strong>主板</strong>)上的芯片组。而适配器则是一块插在主板插槽上的卡。</p><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>​        主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组<strong>动态随机存取存储器(DRAM)</strong>芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。</p><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>​        <strong>中央处理单元(CPU)</strong>，简称<strong>处理器</strong>，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或<strong>寄存器</strong>)，称为<strong>程序计数器(PC)</strong>。在任何时刻，PC都指向主存中的某条机器指令(即含有该条指令的地址)。</p><p>​        从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由<strong>指令集架构</strong>决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC， 使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</p><p>​        这样的简单操作并不多，它们围绕着主存、<strong>寄存器文件（register file)</strong>和<strong>算术/逻辑单元(ALU)</strong>进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。</p><ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原<br>来的内容。</li><li>操作：把两个寄存器的内容复制到ALU, ALU 对这两个字做算术运算，并将结果<br>存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC)中，以覆盖PC 中原来的值。</li></ul><p>​        处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/2.png" srcset="/img/loading.gif" alt="高速缓存存储器"></p><p>​        根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为<strong>高速缓存存储器(cache memory</strong>, 简称为<strong>cache</strong>或<strong>高速缓存</strong>)，作为暂时的集结区域，存放处理器近期可能会需要的信息。位于处理器芯片上的<strong>L1 高速缓存</strong>的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的<strong>L2 高速缓存</strong>通过一条特殊的总线连接到处理器。进程访问L2 高速缓存的时间要比访问L1 高速缓存的时间长5 倍，但是这仍然比访问主存的时间快5~10 倍。L1和L2 高速缓存是用一种叫做<strong>静态随机访问存储器(SRAM)</strong>的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2 和L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p><h3 id="存储设备层次结构"><a href="#存储设备层次结构" class="headerlink" title="存储设备层次结构"></a>存储设备层次结构</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/3.png" srcset="/img/loading.gif" alt="一个存储器层次结构的示例"></p><h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/4.png" srcset="/img/loading.gif" alt="计算机系统的分层视图"></p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/5.png" srcset="/img/loading.gif" alt="操作系统提供的抽象表示"></p><p>​        操作系统有两个基本功能：</p><p>​        1. 防止硬件被失控的应用程序滥用；</p><p>​        2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</p><p>​        操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I/O 设备的抽象表示，虚拟内存是对主存和磁盘I/O 设备的抽象表示，进程则是对处理器、主存和I/O 设备的抽象表示。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​        <strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU 个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</p><p>​        操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，包括许多信息，比如PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/6.png" srcset="/img/loading.gif" alt="进程的上下文切换"></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>​        尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>​        <strong>虚拟内存</strong>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/7.png" srcset="/img/loading.gif" alt="进程的虚拟地址空间"></p><p>​        每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p><ul><li><p><strong>程序代码和数据</strong>。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</p></li><li><p><strong>堆</strong>。代码和数据区后紧随着的是运行时<strong>堆</strong>。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C 标准库函数时，堆可以在运行时动态地扩展和收缩。</p></li><li><p><strong>共享库</strong>。大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</p></li><li><p><strong>栈</strong>。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</p></li><li><p><strong>内核虚拟内存</strong>。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</p></li></ul><p>​        虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>​        文件就是字节序列，仅此而已。每个I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输人输出都是通过使用一小组称为Unix I/O 的系统函数调用读写文件来实现的。</p><h3 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/8.png" srcset="/img/loading.gif" alt="网络也是一种I/O设备"></p><p>​        现代操作系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个I/O 设备，如图所示。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p><p>​        随着Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为<br>计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP和telnet 这样的应用都是基于网络复制信息的功能。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/9.png" srcset="/img/loading.gif" alt="利用telnet通过网络远程运行hello"></p><h3 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h3><p>​        该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为$T_{old}$。假设系统某部分所需执行时间与该时间的比例为 $\alpha$，而该部分性能提升比例为 $k$。即该部分初始所需时间为 $\alpha T_{old}$ ，现在所需时间为$\alpha T_{old}/k$。因此，总的执行时间应为<br>$$<br>T_{new} = (1-\alpha)T_{old} + (\alpha T_{old})/k = T_{old} [(1-\alpha)+\alpha/k]<br>$$<br>由此，可以计算加速比$S =T_{new}/T_{old} $为<br>$$<br>S = \frac{1}{(1-\alpha)+\alpha/k}<br>$$<br>考虑 $k$ 趋向于$\infty$时</p><p>$$<br>S_\infty = \frac{1}{1-\alpha}<br>$$</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>​        我们用的术语<strong>并发(concurrency)</strong>是一个通用的概念，指一个同时具有多个活动的系统；而术语<strong>并行（parallelism)</strong>指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。</p><h4 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h4><p>​        构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。传统意义上，这种并发执行只是<strong>模拟</strong>出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为<strong>单处理器系统</strong>。</p><p>​        当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个<strong>多处理器系统</strong>。</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/10.png" srcset="/img/loading.gif" alt="不同处理器配置分类"></p><p>多核处理器是将多个CPU(称为“核”)集成到一个集成电路芯片上</p><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/11.png" srcset="/img/loading.gif" alt="多核处理器的组织结构"></p><p>​        <strong>超线程</strong>，有时称为<strong>同时多线程(simultaneous multi-threading)</strong>, 是一项允许一个CPU执行多个控制流的技术。它涉及CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约20 000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU 能够更好地利用它的处理资源。</p><p>​        多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过50年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。</p><h4 id="指令级并发"><a href="#指令级并发" class="headerlink" title="指令级并发"></a>指令级并发</h4><p>​        在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。在<strong>流水线(pipelining)</strong>中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。</p><h4 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h4><p>​        在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为<strong>单指令、多数据</strong>，即<strong>SIMD 并行</strong>。例如，较新几代的Intel 和AMD处理器都具有并行地对8 对单精度浮点数(C 数据类型float)做加法的指令。</p><p>​        提供这些SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C 程序中自动抽取SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC 就支持向量数据类型。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p><img src="https://vinkle-image-1302582473.cos.ap-shanghai.myqcloud.com/artical/csapp-1/12.png" srcset="/img/loading.gif" alt="虚拟机"></p><p>​        <strong>虚拟机</strong>，它提供对整个计算机的抽象，包括操作系统、处理器和程序。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
